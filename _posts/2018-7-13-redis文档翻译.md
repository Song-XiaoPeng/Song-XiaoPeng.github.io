 ### Redis Document

#### Redis configuration file example.

>Note that in order to read the configuration file, Redis must be
started with the file path as first argument:
 
注意，为了读配置文件，Redis在启动时必须把这个文件的路径作为第一个参数：
 ./redis-server /path/to/redis.conf

>Note on units: when memory size is needed, it is possible to specify
it in the usual form of 1k 5GB 4M and so forth:
 
 注意这些单元：当需要内存大小时，可以将它指定为1k 5GB 4M等通常的格式，如下所示：
 ```
 1k => 1000 bytes
 1kb => 1024 bytes
 1m => 1000000 bytes
 1mb => 1024*1024 bytes
 1g => 1000000000 bytes
 1gb => 1024*1024*1024 bytes
```
>units are case insensitive so 1GB 1Gb 1gB are all the same.
单元是大小写不敏感的，所以1Gb和1gb是一样的。
#### INCLUDES 
includes包含文件

>Include one or more other config files here.  This is useful if you
have a standard template that goes to all Redis servers but also need
to customize a few per-server settings.  Include files can include
other files, so use this wisely.
在这里包含一个或更多的其它的配置文件。如果你有一个标准模板的话，这是有用的，这个模板转到（定位）所有的Redis服务器，这些服务器也需要定义一些新的单一的服务器设置。包含文件可以包含其他的文件，所以明智的使用它们。

>Notice option "include" won't be rewritten by command "CONFIG REWRITE"
 from admin or Redis Sentinel. Since Redis always uses the last processed
 line as value of a configuration directive, you'd better put includes
 at the beginning of this file to avoid overwriting config change at runtime.

注意选项 include 不会被来自管理员或者redis集群的 "CONFIG REWRITE" 命令重写。因为Redis使用最后的进程线作为一个配置指令的值，你最好把includes放在这个文件的开始处，避免在运行时候覆盖改变配置。

由于Redis总是使用最后处理过的行作为配置指令的值，所以最好在这个文件的开头添加include，以避免在运行时覆盖配置更改。

 >If instead you are interested in using includes to override configuration
 options, it is better to use include as the last line.

 如果有兴趣使用includes覆盖一个配置选项，最好在最后一行使用include。

```
 include /path/to/local.conf
 include /path/to/other.conf
```
#### NETWORK 
网络

> By default, if no "bind" configuration directive is specified, Redis listens
 for connections from all the network interfaces available on the server.
 It is possible to listen to just one or multiple selected interfaces using
 the "bind" configuration directive, followed by one or more IP addresses.
 
 默认情况下，如果没有指定bind配置指令，Redis从这台服务器上所有可能的网络接口中监听连接。
  可以使用bind配置指令监听仅仅一个或多个选定的接口，和面跟着一个或多个IP地址。
 
 >Examples:
```
 bind 192.168.1.100 10.0.0.1
 bind 127.0.0.1 ::1
```
 >~~~ WARNING ~~~ If the computer running Redis is directly exposed to the
 internet, binding to all the interfaces is dangerous and will expose the
 instance to everybody on the internet. So by default we uncomment the
 following bind directive, that will force Redis to listen only into
 the IPv4 lookback interface address (this means Redis will be able to
 accept connections only from clients running into the same computer it
 is running).
 
如果电脑正在运行Redis是直接的暴漏给互联网的，绑定所有的接口是危险的，将会把这个实例暴露给互联网上的每一个人。因此，默认我们取消注释下面的邦定指令，它将强制Redis仅仅去监听IPv4贿赂接口地址（这意味着redis将只能接受运行在同一台正在运行的计算机上的客户端的请求）

 >IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
 JUST COMMENT THE FOLLOWING LINE.
 
如果你确定你想让你的实例监听所有的接口，只需要注释下面的这一行。
``` 
bind 127.0.0.1
```
>Protected mode is a layer of security protection, in order to avoid that
 Redis instances left open on the internet are accessed and exploited.
 
保护模式是一层安全守卫，为了避免redis实例在已授权的互联网上开启。
保护模式是一层安全保护，以避免在internet上打开的Redis实例被访问和利用。

> When protected mode is on and if:

当保护模式启动时，如果

 1. The server is not binding explicitly to a set of addresses using the
    "bind" directive.

服务器没有使用bind指令精确的绑定一个地址的集合。

 2. No password is configured.

没有配置密码

>The server only accepts connections from clients connecting from the
 IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain
 sockets.

服务器仅仅接受来自于IPv4和IPv6回路地址127.0.0.1 或 ::1的客户端的请求，和来自于Unix域名套接字。

> By default protected mode is enabled. You should disable it only if
 you are sure you want clients from other hosts to connect to Redis
 even if no authentication is configured, nor a specific set of interfaces
 are explicitly listed using the "bind" directive.

默认情况下，安全模式是被启用的。仅仅当你确定你想要来自于其它主机的客户端去连接Redis，即使没有配置权限，并且没有一个指定的精确的使用bind指令监听接口集合，你应该禁用它
启用默认保护模式。只有当您确定您希望其他主机的客户端连接到Redis时，您才应该禁用它，即使没有配置身份验证，也没有使用“bind”指令显式列出特定的接口集。

>protected-mode yes

> Accept connections on the specified port, default is 6379 (IANA 815344).
 If port 0 is specified Redis will not listen on a TCP socket.

接收在指定的端口上的连接，默认是6379，如果端口指定的是0，redis将不监听TCP套接字

>port 6379

> TCP listen() backlog.

TCP监听储备（积累，压力）

> In high requests-per-second environments you need an high backlog in order
 to avoid slow clients connections issues. Note that the Linux kernel
 will silently truncate it to the value of /proc/sys/net/core/somaxconn so
 make sure to raise both the value of somaxconn and tcp_max_syn_backlog
 in order to get the desired effect.

在高的每秒请求环境下，你需要一个高的压力，避免缓慢的客户端连接问题。注意，linux内核将安静的将它截断为/proc/sys/net/core/somaxconn的值，因此，确保同时增加somaxconn和tcp_max_syn_backlog的值，去获得期望的影响。

在每秒请求数高的环境中，您需要一个高待办事项列表，以避免客户机连接速度慢的问题。确保同时提高somaxconn和tcp_max_syn_backlog的值，以获得所需的效果。

>tcp-backlog 511

> Unix socket.

unix套接字

> Specify the path for the Unix socket that will be used to listen for
 incoming connections. There is no default, so Redis will not listen
 on a unix socket when not specified.

为unix套接字指定路径，将被用于监听即将到来的连接。没有默认值，因此当没有指定时，redis将不去监听unix套接字
 ```
 unixsocket /tmp/redis.sock
 unixsocketperm 700
```
 >Close the connection after a client is idle for N seconds (0 to disable)

在客户端闲置N秒时候关闭连接，0时禁用。

>timeout 0

 >TCP keepalive.

TCP长连接

 >If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence
 of communication. This is useful for two reasons:

如果不是0，在沟通缺少时使用SO_KEEPALIVE向客户端发送TCP ACKS。有两个原因说明这是有用的：
如果非零，则使用SO_KEEPALIVE在没有通信的情况下将TCP报价单发送给客户端。这之所以有用，有两个原因:

 1. Detect dead peers.
 2. Take the connection alive from the point of view of network
    equipment in the middle.

侦测死的对等点。  
从在中间的网络设备视口中使连接活的。  
从中间的网络设备的角度来看，动态连接。  

 >On Linux, the specified value (in seconds) is the period used to send ACKs.
 Note that to close the connection the double of the time is needed.
 On other kernels the period depends on the kernel configuration.

在linux中，指定的值是（按秒）是顺序的发送ACK。注意，关闭双的连接是需要的。
在别的内核中，周期依赖于内核的配置

指定的值(以秒为单位)是用于发送ack的周期。注意，要关闭连接，需要双倍的时间。

> A reasonable value for this option is 60 seconds.

这个配置的一个合理的值是60秒。

>tcp-keepalive 0

 GENERAL 
通用
 By default Redis does not run as a daemon. Use 'yes' if you need it.
 Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
默认，redis不会以守护进程的方式运行。如果你需要这样使用yes。
注意，reds在以守护进程方式运行时将在/var/run/redis.pid中写一个pid文件。
daemonize yes

 If you run Redis from upstart or systemd, Redis can interact with your
 supervision tree. Options:
   supervised no      - no supervision interaction 没有监督交互
   supervised upstart - signal upstart by putting Redis into SIGSTOP mode 信号upstart通过将redis设置为sigstop模式
   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET 标志systemd通过写ready=1到$notify_socket
   supervised auto    - detect upstart or systemd method based on  发现以UPSTART_JOB为环境变量为基础的upstart或者systemd的方法
                        UPSTART_JOB or NOTIFY_SOCKET environment variables
 Note: these supervision methods only signal "process is ready."   注意：这些管理方法仅仅表示进程准备好了。
       They do not enable continuous liveness pings back to your supervisor.   它们不确保连续的活跃脉冲返回给你的监督者
如果你从upstart或者system运行redis，Redis可以与您的监督树交互。选项:
supervised no

 If a pid file is specified, Redis writes it where specified at startup
 and removes it at exit.
如果一个pid文件被指定，redis将把它写到在启动时指定的地方，并且在结束（退出）时移动（删除）它。

 When the server runs non daemonized, no pid file is created if none is
 specified in the configuration. When the server is daemonized, the pid file
 is used even if not specified, defaulting to "/var/run/redis.pid".
当服务不是以守护进程方式运行时，如果在配置文件中没有指定则不会创建pid文件。当服务是以守护进程方式运行时，pid文件会被使用即使没有被指定，默认为"/var/run/redis.pid"

 Creating a pid file is best effort: if Redis is not able to create it
 nothing bad happens, the server will start and run normally.
创建一个pid文件是最好的，如果redis不能创建，服务器将正常的启动或者运行。
pidfile /var/run/redis.pid （Process Identification）进程代号

 Specify the server verbosity level.
 This can be one of:
 debug (a lot of information, useful for development/testing)  调试（大量的信息，对于开发和测试是有用的）
 verbose (many rarely useful info, but not a mess like the debug level) 冗长（许多很少有用的信息，但是不像调试模式那么多）
 notice (moderately verbose, what you want in production probably) 注意（适度的冗长，在生产环境中你最可能想要的）
 warning (only very important / critical messages are logged)  警告（只有非常重要、危险的消息被记录）
指定服务器冗长等级
可以是下面中的其一：
loglevel notice

 Specify the log file name. Also the empty string can be used to force
 Redis to log on the standard output. Note that if you use standard
 output for logging but daemonize, logs will be sent to /dev/null
指定日志文件名称。空的字符串也可以使用，强制redis在标准输出上记录。注意，如果你使用标准输出来记录而不是守护进程方式，日志将被发送到/dev/null
logfile "/var/log/redis.log"

 To enable logging to the system logger, just set 'syslog-enabled' to yes,
 and optionally update the other syslog parameters to suit your needs.
 syslog-enabled no
确保记录到系统日志管理者中， 只需设置为yes，可选择的更新别的syslog参数来适应你的需求。

 Specify the syslog identity.
 syslog-ident redis
指定syslog身份

 Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
 syslog-facility local0
指定syslog设备。必须是user或者LOCAL0-LOCAL7之间

 Set the number of databases. The default database is DB 0, you can select
 a different one on a per-connection basis using SELECT <dbid> where
 dbid is a number between 0 and 'databases'-1
设置数据库的号码。默认数据库是DB0，你可以使用SELECT dbid命令，dbid是一个0到-1的数字，来在每个连接基础上选择一个不同的号码。
databases 16

 SNAPSHOTTING  
快照

 Save the DB on disk:  在硬盘上保存DB数据库

   save <seconds> <changes>    

   Will save the DB if both the given number of seconds and the given 
   number of write operations against the DB occurred.
将保存DB，如果所给的秒数和所给的写操作的数量和已存在的DB冲突了。
如果同时发生给定的秒数和给定的针对DB的写操作数，将保存DB。
   In the example below the behaviour will be to save: 在下面的例子中行为将被保存
   after 900 sec (15 min) if at least 1 key changed    在900秒之后，如果至少1个键改变
   after 300 sec (5 min) if at least 10 keys changed   在300秒之后，如果至少10个键改变了
   after 60 sec if at least 10000 keys changed         在60秒之后，如果至少10000个键改变了

   Note: you can disable saving completely by commenting out all "save" lines.
注意：你可以完全的禁止保存，通过注释所有的save行
   It is also possible to remove all the previously configured save
   points by adding a save directive with a single empty string argument
   like in the following example:
也可以删除所有之前定义的save点，通过添加一个单独的空字符串参数的save指令，像之后的这个例子一样：
   save ""

save 900 1
save 300 10
save 60 10000

 By default Redis will stop accepting writes if RDB snapshots are enabled
 (at least one save point) and the latest background save failed.
 This will make the user aware (in a hard way) that data is not persisting
 on disk properly, otherwise chances are that no one will notice and some
 disaster will happen.

 If the background saving process will start working again Redis will
 automatically allow writes again.

 However if you have setup your proper monitoring of the Redis server
 and persistence, you may want to disable this feature so that Redis will
 continue to work as usual even if there are problems with disk,
 permissions, and so forth.
默认情况下，如果RDB快照是起作用的（至少一个save点）和最后的后台保存失败了，那么redis将停止接受写操作。
这将让用户意识到（一个艰难的方式）数据没有合适的存留在硬盘上，否则没有人将注意到这个可能性，一些灾难将会发生。
）数据没有合适的存留在硬盘上，否则没有人将注意到这个可能性，一些灾难将会发生。

如果后台保存进程将再一次的开始工作，redis将再一次自动的允许写。

然而，如果你设置了你的合适的redis服务器和保存的配置，你可能想去禁用这个特性，这样redis将继续正常的工作，即使硬盘有一些问题，权限，等等。

stop-writes-on-bgsave-error yes

 Compress string objects using LZF when dump .rdb databases?
 For default that's set to 'yes' as it's almost always a win.
 If you want to save some CPU in the saving child set it to 'no' but
 the dataset will likely be bigger if you have compressible values or keys.
当导出rdb数据库时使用LZF压缩字符对象吗？
默认它被设置为yes
如果你想要在save子进程中保存一些CPU，将它设置为no，但是如果你有可压缩的值或键，数据集可能会变的更大。
rdbcompression yes

 Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
 This makes the format more resistant to corruption but there is a performance
 hit to pay (around 10%) when saving and loading RDB files, so you can disable it
 for maximum performances.

 RDB files created with checksum disabled have a checksum of zero that will
 tell the loading code to skip the check.
自RDB版本5以来，一个crc64的校验和放置在这个文件的末尾。
这使格式更不容易被破坏的，但是，当保存和加载RDB文件时，会有性能损失（在10%左右），因此你可以由于最大的运行而禁止它。

这使得这种格式更不容易损坏，但是在保存和加载RDB文件时，会有性能损失(大约10%)，因此您可以禁用它以获得最大性能。

RDB文件和校验和为0的禁用的校验和一起创建，将告诉加载的码来跳过检查。

禁用校验和创建的RDB文件的校验和为零，它将告诉加载代码跳过校验。

rdbchecksum yes

 The filename where to dump the DB
导出DB到哪个文件
在何处转储DB的文件名
dbfilename sone_dump.rdb

 The working directory.

 The DB will be written inside this directory, with the filename specified
 above using the 'dbfilename' configuration directive.

 The Append Only File will also be created inside this directory.

 Note that you must specify a directory here, not a file name.
工作目录
DB将和上面使用dbfilename配置指令指定的文件名一起被写到这个目录里面。
只有追加的文件也能够在这个目录里面创建。
注意你必须在这里指定一个目录，而不是文件名
dir ~/tmp

 REPLICATION 
replication 主从复制
 Master-Slave replication. Use slaveof to make a Redis instance a copy of
 another Redis server. A few things to understand ASAP about Redis replication.

主从复制，使用slaveof指令创建一个redis实例，这个实例是另一个redis服务的拷贝。一些东西有助于理解ASAP关于redis主从复制。
关于Redis复制，有几点需要尽快理解。
 1) Redis replication is asynchronous, but you can configure a master to
    stop accepting writes if it appears to be not connected with at least
    a given number of slaves.
redis主从复制是异步的，但是你可以配置一个主服务器来终止接受写操作，如果主服务器似乎没有和至少一个给予数量的从服务器连接时。
 2) Redis slaves are able to perform a partial resynchronization with the
    master if the replication link is lost for a relatively small amount of
    time. You may want to configure the replication backlog size (see the next
    sections of this file) with a sensible value depending on your needs.
redis从服务器可以和主服务器执行一部分的重复同步，如果主从复制连接丢失一个相关的小数量的时间。你可能想要去使用一个你需要的明智的值来配置主从复制backlog（储备，积压）大小（看这个文件的下一段）
 3) Replication is automatic and does not need user intervention. After a
    network partition slaves automatically try to reconnect to masters
    and resynchronize with them.
主从复制是自动的，并且不需要用户的介入。在网络部分从服务器自动的尝试重新连接主服务器和重新备份（同步）他们时。
在网络分区之后，从服务器自动尝试重新连接到主服务器并与它们重新同步
 slaveof <masterip> <masterport>

 If the master is password protected (using the "requirepass" configuration
 directive below) it is possible to tell the slave to authenticate before
 starting the replication synchronization process, otherwise the master will
 refuse the slave request.

 masterauth <master-password>
如果主服务器是密码保护的（使用requirepass配置指令在下面），告诉从服务器启动主从复制同步进程之前进行认证，否则主服务器将拒绝从服务器的请求
在启动复制同步进程之前，可以告诉奴隶进行身份验证，否则主将拒绝从属请求。
 When a slave loses its connection with the master, or when the replication
 is still in progress, the slave can act in two different ways:

 1) if slave-serve-stale-data is set to 'yes' (the default) the slave will
    still reply to client requests, possibly with out of date data, or the
    data set may just be empty if this is the first synchronization.

 2) if slave-serve-stale-data is set to 'no' the slave will reply with
    an error "SYNC with master in progress" to all the kind of commands
    but to INFO and SLAVEOF.

当一个从库失去了和主库的连接，或者当主从复制仍在进行中，从服务器可以表现为两种不同的方式：

1 如果slave-serve-stale-data（从服务器旧数据）配置项设置为yes（默认），从服务器将回答客户端的请求，可能和超过日期的（过时的）数据，或者如果这是第一次同步数据集可能只是空的
2 如果slave-serve-stale-data设置为no，从服务器将答复给所有除了INFO和SLAVEOF命令一个错误“和主库的同步在进行中（同步主进程）”
slave-serve-stale-data yes

 You can configure a slave instance to accept writes or not. Writing against
 a slave instance may be useful to store some ephemeral data (because data
 written on a slave will be easily deleted after resync with the master) but
 may also cause problems if clients are writing to it because of a
 misconfiguration.

 Since Redis 2.6 by default slaves are read-only.

 Note: read only slaves are not designed to be exposed to untrusted clients
 on the internet. It's just a protection layer against misuse of the instance.
 Still a read only slave exports by default all the administrative commands
 such as CONFIG, DEBUG, and so forth. To a limited extent you can improve
 security of read only slaves using 'rename-command' to shadow all the
 administrative / dangerous commands.
你可以配置一个从服务器实例来接受写操作或者不这样。写操作一个从服务实例对存储一些临时数据是有用的（因为在从数据库上被写的数据将会在和主库再同步之后容易的删除）但是如果客户端由于一个错误的配置正在写也可能引起问题。
对从实例进行写入对于存储一些临时数据可能很有用，因为写在从服务器上的数据在与主服务器重新同步后很容易被删除。但是，如果客户因为配置错误而写信给它，也可能会造成问题。

自从redis2.6起，默认的从服务器时只读的

注意：只读从服务器没有被设计为暴露给不真实的互联网上客户端。这只是对误用这个实例的一个保护。（它只是一个防止实例被滥用的保护层。）一个只读的从服务器默认导出所有的管理员的命令，例如：CONFIG，DEBUG，等等。你可以使用rename-command命令，隐藏所有的管理/危险的命令，提高只读从属的安全性。
在一定程度上，您可以通过使用“rename-command”对所有管理/危险的命令进行阴影来提高只读从属的安全性
slave-read-only yes

 Replication SYNC strategy: disk or socket.
 主从服务同步策略：硬盘或者套接字
 -------------------------------------------------------
 WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY diskless replication is experimental currently
 -------------------------------------------------------
 警告：硬盘缺少的主从复制是 (无盘复制目前还处于实验阶段)
 New slaves and reconnecting slaves that are not able to continue the replication
 process just receiving differences, need to do what is called a "full
 synchronization". An RDB file is transmitted from the master to the slaves.
 The transmission can happen in two different ways:
新的从库和重新连接的从库不能够继续主从复制进程而是只能接收不同，需要去做被称作full synchronization 全同步的事。一个RDB文件被从主库传递给从库。
这个传递可以以两种不同的方式发生：
 1) Disk-backed: The Redis master creates a new process that writes the RDB
                 file on disk. Later the file is transferred by the parent
                 process to the slaves incrementally.
硬盘支持的：redis主库创建一个新的进程，写入硬盘上的RDB文件。之后，这个文件被父进程递增地转变到从库。
 2) Diskless: The Redis master creates a new process that directly writes the
              RDB file to slave sockets, without touching the disk at all.

无盘的：redis主库创建一个新的进程，直接向从库的套接字写一个RDB文件，没有涉及（接触）到硬盘。
 With disk-backed replication, while the RDB file is generated, more slaves
 can be queued and served with the RDB file as soon as the current child producing
 the RDB file finishes its work. With diskless replication instead once    
 the transfer starts, new slaves arriving will be queued and a new transfer
 will start when the current one terminates.

硬盘支持的主从复制，会生成RDB文件，更多的从库可以和RDB文件，当当前子进程生产RDB文件结束时
使用磁盘支持的复制，当生成RDB文件时，只要生成RDB文件的当前子（文件）进程完成其工作，就可以对更多的从服务器进行排队并使用RDB文件。一旦传输开始，无盘主从复制替代，新的到达的从库将排队，当当前的传输结束后一个新的传输将开始。
使用无磁盘复制时，一旦传输开始，将会有新的从服务器进入队列，并且在当前从服务器传输终止时将开始新的传输。
 When diskless replication is used, the master waits a configurable amount of
 time (in seconds) before starting the transfer in the hope that multiple slaves
 will arrive and the transfer can be parallelized.

 With slow disks and fast (large bandwidth) networks, diskless replication
 works better.
当无盘主从复制被使用是，主服务器等待一个可设置数量的时间（秒数），在开始一个期望的传输之前，多个从服务器将到达，传输可以并行化。
当使用无磁盘复制时，主服务器在启动传输之前等待一个可配置的时间量(以秒为单位)，希望多个从服务器到达，并且传输可以并行化。

当使用慢的硬盘和快的网络（大的带宽）时，无盘主从复制更好的工作。
repl-diskless-sync no

 When diskless replication is enabled, it is possible to configure the delay
 the server waits in order to spawn the child that transfers the RDB via socket
 to the slaves.

 This is important since once the transfer starts, it is not possible to serve
 new slaves arriving, that will be queued for the next RDB transfer, so the server
 waits a delay in order to let more slaves arrive.

 The delay is specified in seconds, and by default is 5 seconds. To disable
 it entirely just set it to 0 seconds and the transfer will start ASAP.
当无盘主从复制是启用的，可以配置，服务器等待，传递RDB套接字给从库。

当启用无磁盘复制时，可以配置服务器等待的延迟，以便生成通过套接字将RDB传输到从服务器的子代。

一旦一个传输开始后，这是重要的，不会去服务新的到达的从库，它将进入队列来等待下一次的RDB传递，因此，服务器等待一个延迟来让更多的从库到达。

这个延迟被以秒为单位制定，默认是5秒。完全禁用它只需设置为0秒，传输将尽快开始。

repl-diskless-sync-delay 5

 Slaves send PINGs to server in a predefined interval. It's possible to change
 this interval with the repl_ping_slave_period option. The default value is 10
 seconds.

从库用一个预定义的时间间隔向服务器发送脉冲。可以使用repl_ping_slave_period选项改变这个时间间隔，。默认的值是10秒。
 repl-ping-slave-period 10

 The following option sets the replication timeout for:

下面的选项设置主从超时时间：
 1) Bulk transfer I/O during SYNC, from the point of view of slave.
 2) Master timeout from the point of view of slaves (data, pings).
 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).

在同步的过程中，来自于从库的视角。在同步过程中，从从属的角度来看，批量传输I/O
主库超时来自于从库的视角。从奴隶的角度看的主超时(数据，ping)
从超时，从主库的角度来看（回复配置 ACK 脉冲）。
 It is important to make sure that this value is greater than the value
 specified for repl-ping-slave-period otherwise a timeout will be detected
 every time there is low traffic between the master and the slave.

重要的是要确保这个值比repl-ping-slave-period指定的值要大，否则一个超时将每个时间，在主和从之间是
每次主服务器和从服务器之间的通信流量较低时，都会检测到超时。
 repl-timeout 60

 Disable TCP_NODELAY on the slave socket after SYNC?

禁用从套接字上的TCP_不搁置，在同步之后？
 If you select "yes" Redis will use a smaller number of TCP packets and
 less bandwidth to send data to slaves. But this can add a delay for
 the data to appear on the slave side, up to 40 milliseconds with
 Linux kernels using a default configuration.

如果你选择了yes，redis将使用一个小的TCP包数量，更少的带宽来向从库发送数据。但是这可以为这个将要出现在从服务器这边的数据添加一个延迟，linux内核使用默认的配置会超过40毫秒。
 If you select "no" the delay for data to appear on the slave side will
 be reduced but more bandwidth will be used for replication.

如果你选择了no，出现在从服务器这边的延迟将减少，但是更多的带宽将被用作主从复制。
 By default we optimize for low latency, but in very high traffic conditions
 or when the master and slaves are many hops away, turning this to "yes" may
 be a good idea.
默认情况下，我们优化低的延迟，但是在非常高的流量状况下，或者当主和从有许多跳跃时（非常活跃时），将它转变为yes是一个好的主意。
repl-disable-tcp-nodelay no

 Set the replication backlog size. The backlog is a buffer that accumulates
 slave data when slaves are disconnected for some time, so that when a slave
 wants to reconnect again, often a full resync is not needed, but a partial
 resync is enough, just passing the portion of data the slave missed while
 disconnected.

设置主从复制储备大小。储备是一个缓冲，积累从数据，当从库失去连接一段时间时，因此，当一个从库想要重新连接时，通常一个完整的重新同步不需要，一个分步的重新同步是足够的，只需要在失去连接时传递从库丢失的那部分数据。
 The bigger the replication backlog, the longer the time the slave can be
 disconnected and later be able to perform a partial resynchronization.
主从复制储存的越大，从库可以被断开连接的时间越长，之后可以运行一个部分的重新同步。
复制待办事项列表越大，从服务器断开连接的时间就越长，之后就可以执行部分重新同步。
 The backlog is only allocated once there is at least a slave connected.
储存只允许，当至少一个从库被连接时。
只有在连接到至少一个从属节点时，才分配backlog。
 repl-backlog-size 1mb

 After a master has no longer connected slaves for some time, the backlog
 will be freed. The following option configures the amount of seconds that
 need to elapse, starting from the time the last slave disconnected, for
 the backlog buffer to be freed.
有时，在主库没有已连接的从库之后，储存（备份）将被释放。下面的选项为需要释放的备份缓存配置了需要消耗的秒数，这个时间从最后一个从库断开连接开始。
下面的选项将配置从最后一个从服务器断开连接开始需要经过的秒数，以便释放backlog缓冲区。
值0意味着永远不释放备份。

 repl-backlog-ttl 3600

 The slave priority is an integer number published by Redis in the INFO output.
 It is used by Redis Sentinel in order to select a slave to promote into a
 master if the master is no longer working correctly.
从库的优先权是一个整型的数字，是redis在info输出中发布的。
被用于redis哨兵，来选择一个从库来提升（升级为提升为）主库，如果主库不在正确的工作。
 A slave with a low priority number is considered better for promotion, so
 for instance if there are three slaves with priority 10, 100, 25 Sentinel will
 pick the one with priority 10, that is the lowest.
低优先权数字低的从库对于提升为主库被考虑（认为）为更好的，因此，对于实例来说，如果有三个从库，优先权为10，100，25，哨兵将选择那个优先权为10的，最低的那个。
一个低优先级的奴隶被认为更适合提升，所以如果有三个拥有优先级10,100,25sentinel的奴隶会选择优先级为10的奴隶，这是最低的。
 However a special priority of 0 marks the slave as not able to perform the
 role of master, so a slave with priority of 0 will never be selected by
 Redis Sentinel for promotion.
然而指定优先权0标示从库不能作为主库的角色运行，因此优先权为0的从库将从不会被redis哨兵选择作为提升。
 By default the priority is 100.
默认优先权是100。
slave-priority 100

 It is possible for a master to stop accepting writes if there are less than
 N slaves connected, having a lag less or equal than M seconds.
对于主库，可以停止接受写操作，如果少于n个从库连接，延迟小于或等于m秒。
 The N slaves need to be in "online" state.
这N个从库需要是在线的状态。
 The lag in seconds, that must be <= the specified value, is calculated from
 the last ping received from the slave, that is usually sent every second.
延迟以秒为单位，必须<=指定的值，从最后一次接收到从库的脉冲计算，通常每秒发送一次。
 This option does not GUARANTEE that N replicas will accept the write, but
 will limit the window of exposure for lost writes in case not enough slaves
 are available, to the specified number of seconds.
这个配置不会guarantee授权，N个回复将接受写操作，但是由于失去写操作将限制暴露的窗口，在没有充足可用的从库时，指定的秒数。
此选项不保证N个副本将接受写操作，但如果没有足够的从服务器可用，则将丢失写的暴露窗口限制为指定的秒数。
 For example to require at least 3 slaves with a lag <= 10 seconds use:
例如，<=10秒的延迟来获得至少3个从库，使用这个配置：
 min-slaves-to-write 3
 min-slaves-max-lag 10

 Setting one or the other to 0 disables the feature.
设置一个或者另一个为0来禁用这项特性。
 By default min-slaves-to-write is set to 0 (feature disabled) and
 min-slaves-max-lag is set to 10.
默认最小从库写设置为0，禁用特性，最小从库最大延迟设置为10。

 SECURITY 
安全
 Require clients to issue AUTH <PASSWORD> before processing any other
 commands.  This might be useful in environments in which you do not trust
 others with access to the host running redis-server.

需要客户端发出AUTH密码，在处理任何其它命令之前。在那些你不信任别人访问这台主机上运行的redis服务器的环境下，这可能是有用的。
这在不信任其他访问运行redis-server的主机的环境中可能很有用。
 This should stay commented out for backward compatibility and because most
 people do not need auth (e.g. they run their own servers).

应该保留注释，对于以后的兼容性（为了向后兼容），因为大多数人不需要认证（它们在自己的服务器上运行）。
 Warning: since Redis is pretty fast an outside user can try up to
 150k passwords per second against a good box. This means that you should
 use a very strong password otherwise it will be very easy to break.

警告：因为redis是非常快的，外边的用户可以尝试每秒150k个密码攻击一个好的服务器。这意味着，你应该使用一个非常强壮的密码，否则它将会非常容易的被破坏。
requirepass shop

 Command renaming.

命令重命名
 It is possible to change the name of dangerous commands in a shared
 environment. For instance the CONFIG command may be renamed into something
 hard to guess so that it will still be available for internal-use tools
 but not available for general clients.

可以在一个共享的环境中改变危险命令的名字。例如config命令，可以被重命名为其它难以被踩到的名字，这样它对于内部使用工具来说仍然是可用的，但是对于普通的客户端来说就不能用了。
 Example:例子：

 rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52

 It is also possible to completely kill a command by renaming it into
 an empty string:

也可以完全取消一个命令，通过把它命名为空字符串：
 rename-command CONFIG ""

 Please note that changing the name of commands that are logged into the
 AOF file or transmitted to slaves may cause problems.
请注意：改变命令的名字，被记录到AOF文件中，或者传递到从库中会引发问题。
 LIMITS 
限制
 Set the max number of connected clients at the same time. By default
 this limit is set to 10000 clients, however if the Redis server is not
 able to configure the process file limit to allow for the specified limit
 the max number of allowed clients is set to the current file limit
 minus 32 (as Redis reserves a few file descriptors for internal uses).
设置可同时连接的客户端的最大数量。默认，这个限制设置为10000个客户端，然而，如果redis服务器不能配置进程文件限制，来允许指定的限制，最大的允许连接客户端数量被设置为当前文件限制减去32（因为Redis保存一些新的文件描述者来作为内部使用）。
 Once the limit is reached Redis will close all the new connections sending
 an error 'max number of clients reached'.
一旦这个限制达到了，redis将会关闭所有的新的连接，并且会发送一个错误‘达到了最大数量的客户端限制’。
 maxclients 10000

 Don't use more memory than the specified amount of bytes.
 When the memory limit is reached Redis will try to remove keys
 according to the eviction policy selected (see maxmemory-policy).

不要使用超过指示数量字节的更多内存。
当内存限制达到了，redis将试图依据所选择的驱除政策（逐出策略）删除键。（看最大内存策略）
 If Redis can't remove keys according to the policy, or if the policy is
 set to 'noeviction', Redis will start to reply with errors to commands
 that would use more memory, like SET, LPUSH, and so on, and will continue
 to reply to read-only commands like GET.
如果redis不能依据策略删除键，或者，如果这个策略被设置为‘noeviction’（不驱逐），redis将开始回复错误给那些使用更多内存的命令，例如set，lpush，等等， 并且将继续回复只读的命令，比如GET。
 This option is usually useful when using Redis as an LRU cache, or to set
 a hard memory limit for an instance (using the 'noeviction' policy).
这个选项通常是有用的，当使用redis作为一个LRU缓存时，或者为一个实例设置一个困难的内存限制（使用不逐出策略）。设置实例的硬内存限制(使用“nostare tion”策略)时
 WARNING: If you have slaves attached to an instance with maxmemory on,
 the size of the output buffers needed to feed the slaves are subtracted
 from the used memory count, so that network problems / resyncs will
 not trigger a loop where keys are evicted, and in turn the output
 buffer of slaves is full with DELs of keys evicted triggering the deletion
 of more keys, and so forth until the database is completely emptied.
注意：如果你有从库依附于一个实例，同时开启了最大内存限制，需要供给从库的输出缓冲的大小是从已使用的内存数量中减去的，因此，网络问题/重新同步将不再触发一个键被逐出的循环，轮流的从库的输出缓存将填充为被驱逐键的DELs指令，触发更多键的删除，等等，直到数据库完全为空。
 In short... if you have slaves attached it is suggested that you set a lower
 limit for maxmemory so that there is some free RAM on the system for slave
 output buffers (but this is not needed if the policy is 'noeviction').
总之，如果你有附属的从库，建议你设置一个低的最大内存限制，这样有一些系统上的空闲的RAM（随机访问内存）来作为输出缓存。（但是如果策略是不驱逐的话，不需要这样）。
 maxmemory <bytes>

 MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
 is reached. You can select among five behaviors:

最大内存策略：当到达最大内存时，redis将如何选择来删除什么。你可以选择这这5个之中的行为：
 volatile-lru -> remove the key with an expire set using an LRU algorithm  易失的-lru -> 使用一个LRU算法删除有过期集合的键
 allkeys-lru -> remove any key according to the LRU algorithm  所有的键-lru -> 依据LRU算法来删除任何一个键
 volatile-random -> remove a random key with an expire set     易失的-随机的 -> 使用过期集删除一个随机的键
 allkeys-random -> remove a random key, any key    所有键-随机 随机删除一个键，任何一个键
 volatile-ttl -> remove the key with the nearest expire time (minor TTL)   易失的-生存时间 使用最接近的过期时间删除键（小的生存时间）
 noeviction -> don't expire at all, just return an error on write operations   不驱逐 -- 不过期，只返回一个错误给写操作集。
1.volatile-lru:从设置了过期时间的数据集中，选择最近最久未使用的数据释放

2.allkeys-lru:从数据集中(包括设置过期时间以及未设置过期时间的数据集中)，选择最近最久未使用的数据释放

3.volatile-random:从设置了过期时间的数据集中，随机选择一个数据进行释放

4.allkeys-random:从数据集中(包括了设置过期时间以及未设置过期时间)随机选择一个数据进行入释放

5.volatile-ttl：从设置了过期时间的数据集中，选择马上就要过期的数据进行释放操作

6.noeviction：不删除任意数据(但redis还会根据引用计数器进行释放呦~),这时如果内存不够时，会直接返回错误
 Note: with any of the above policies, Redis will return an error on write
       operations, when there are no suitable keys for eviction.

       At the date of writing these commands are: set setnx setex append
       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
       getset mset msetnx exec sort
注意：在任一个上面的策略中，redis将在写操作上返回一个错误，当没有合适的键驱逐时。
 The default is:
默认值是：

 maxmemory-policy noeviction
最大内存-策略 不驱逐

 LRU and minimal TTL algorithms are not precise algorithms but approximated
 algorithms (in order to save memory), so you can tune it for speed or
 accuracy. For default Redis will check five keys and pick the one that was
 used less recently, you can change the sample size using the following
 configuration directive.
LRU和最小的生存时间算法不是精确的算法，而是接近的（近似）算法（为了节省内存），所以你可以调整它的速度或精度。默认redis将检查5个键，选择最近被使用最少的一个，你可以使用下面的配置指令来改变这个实例值大小。
 The default of 5 produces good enough results. 10 Approximates very closely
 true LRU but costs a bit more CPU. 3 is very fast but not very accurate.
默认为5时可以产生足够好的结果。10近似于非常接近的真的LRU，但会花费一点CPU。3是非常快的，但是不是非常精确。
5的默认值产生了足够好的结果。10非常接近真实的LRU，但是需要多一点CPU。3是非常快，但不是很准确。
 maxmemory-samples 5 
最大内存-实例 5

 APPEND ONLY MODE 
只追加模式
 By default Redis asynchronously dumps the dataset on disk. This mode is
 good enough in many applications, but an issue with the Redis process or
 a power outage may result into a few minutes of writes lost (depending on
 the configured save points).
默认redis异步的在硬盘上导出数据。这个模式在许多应用中是足够好的，但是，由于redis进程的问题或者断电可能导致几分钟的写丢失（依赖于已配置的保存点）。
但是，由于Redis进程的问题或断电，可能会导致几分钟的写入丢失。
 The Append Only File is an alternative persistence mode that provides
 much better durability. For instance using the default data fsync policy
 (see later in the config file) Redis can lose just one second of writes in a
 dramatic event like a server power outage, or a single write if something
 wrong with the Redis process itself happens, but the operating system is
 still running correctly.
只追加文件是一个供选择的（替代的）保存（持久性）模式，提供更好的耐久性。因为实例使用默认的数据fsync策略（稍后在配置文件中看到），redis会失去仅仅一秒的写操作，在一些戏剧性的事件中类似于服务器断电，或者如果redis进程自身发生的一些错误时的单一写，但是这个正在运行的系统仍然会正确的运行。

Append Only文件是另一种持久性模式，提供了更好的持久性。例如使用默认数据fsync策略配置文件中(见后)复述,可以失去只是一秒的写在一个戏剧性的事件像一个服务器断电,或一个写如果复述过程本身出了问题,但正确操作系统仍在运行。
 AOF and RDB persistence can be enabled at the same time without problems.
 If the AOF is enabled on startup Redis will load the AOF, that is the file
 with the better durability guarantees.
AOF和RDB持久化模式，可以同时没有问题的启用。如果AOF在启动时是开启的，那么redis将加载AOF，这个文件有更持久的保证。
 Please check http://redis.io/topics/persistence for more information.
选择来获得更多的信息。

appendonly no

 The name of the append only file (default: "appendonly.aof")
只追加文件的名字（默认：..）
appendfilename "appendonly.aof"

 The fsync() call tells the Operating System to actually write data on disk
 instead of waiting for more data in the output buffer. Some OS will really flush
 data on disk, some other OS will just try to do it ASAP.
fsync()调用，告诉操作系统在硬盘上实际地写数据，而不是等待在输出缓冲中的更多的数据。一些操作系统将真的刷出数据到磁盘上，另一些操作系统只试图尽快的做这件事。
 Redis supports three different modes:
redis支持三种不同的模式：
 no: don't fsync, just let the OS flush the data when it wants. Faster.
 always: fsync after every write to the append only log. Slow, Safest.
 everysec: fsync only one time every second. Compromise.
no不启用: 不启用fsync，让操作系统在它想要时刷出数据。更快。
always总是：fsync 在每次写操作到只追加日志后进行。慢，最安全。
everysec: fsync 每秒只一次。妥协。
 The default is "everysec", as that's usually the right compromise between
 speed and data safety. It's up to you to understand if you can relax this to
 "no" that will let the operating system flush the output buffer when
 it wants, for better performances (but if you can live with the idea of
 some data loss consider the default persistence mode that's snapshotting),
 or on the contrary, use "always" that's very slow but a bit safer than
 everysec.
默认是“每秒”，因为这是通常在速度和数据安全性之间正确的妥协。取决于你的理解，如果你可以设置为no，就会使操作系统在它想要时刷出输出缓存，为了更好的运行（但是如果你有这个想法，一些数据丢失默认的持久化模式是快照），或者相反的，使用“总是”,这是非常慢但是比每秒更安全一点。
(但是，如果您能够忍受某些数据丢失的想法，请考虑默认的持久性模式，即快照模式)
 More details please check the following article:
更详细的请选择下面的这篇文章：
 http://antirez.com/post/redis-persistence-demystified.html

 If unsure, use "everysec".
如果不确定，使用每秒

 appendfsync always
appendfsync everysec
 appendfsync no

 When the AOF fsync policy is set to always or everysec, and a background
 saving process (a background save or AOF log background rewriting) is
 performing a lot of I/O against the disk, in some Linux configurations
 Redis may block too long on the fsync() call. Note that there is no fix for
 this currently, as even performing fsync in a different thread will block
 our synchronous write(2) call.
当AOF fsync（文件同步）策略被设置为总是或者每秒时，并且后台的保存进程（后台保存或者只追加文件记录后台重写）会占用硬盘大量的I/O，在一些linux配置中，redis可能在fsync()调用时阻塞了太长。注意，目前对这个问题还没有解决方法，即使在不同的线程运行fsync也会阻塞我们同步的写调用。
当AOF fsync策略设置为总是或每秒钟，并且后台保存进程(后台保存或AOF日志背景重写)对磁盘执行大量I/O时，在某些Linux配置中，Redis可能会在fsync()调用中阻塞太长时间。
请注意，目前没有对此进行修复，因为即使在不同的线程中执行fsync也会阻塞我们的同步写(2)调用。
 In order to mitigate this problem it's possible to use the following option
 that will prevent fsync() from being called in the main process while a
 BGSAVE or BGREWRITEAOF is in progress.
为了解决这个问题，可以使用如下的选项，当bgsave或者bgrewriteaof在运行中时，这些选项将阻止fsync()在主进程中调用。
 This means that while another child is saving, the durability of Redis is
 the same as "appendfsync none". In practical terms, this means that it is
 possible to lose up to 30 seconds of log in the worst scenario (with the
 default Linux settings).
这意味着，在另一个子进程在保存时，redis的持久化和‘追加文件同步fsync 没有’相同。实际上，这意味着可能失去30秒的日志在最坏的场景中（使用默认的linux设置）。
实际上，这意味着在最坏的情况下(使用默认的Linux设置)，可能会丢失长达30秒的日志。
 If you have latency problems turn this to "yes". Otherwise leave it as
 "no" that is the safest pick from the point of view of durability.
如果你有延迟（潜伏，潜在因素，延迟，潜伏期）问题，将它转变为yes。否则让它为no，这是站在持久化视角的最安全的选择。
no-appendfsync-on-rewrite no

 Automatic rewrite of the append only file.
 Redis is able to automatically rewrite the log file implicitly calling
 BGREWRITEAOF when the AOF log size grows by the specified percentage.
自动重写只追加文件
redis能自动的重写日志文件，bgrewriteaof，当只追加写日志大小被指定的比例增长了。
当AOF日志大小以指定的百分比增长时，Redis能够自动重写隐式调用BGREWRITEAOF的日志文件。
 This is how it works: Redis remembers the size of the AOF file after the
 latest rewrite (if no rewrite has happened since the restart, the size of
 the AOF at startup is used).
这是它工作的方式：redis还记得只追加文件的大小，在最近一次的重写过后。（如果自重启过后还没有重写发生，那么在启动时只追加文件的大小被使用）。

 This base size is compared to the current size. If the current size is
 bigger than the specified percentage, the rewrite is triggered. Also
 you need to specify a minimal size for the AOF file to be rewritten, this
 is useful to avoid rewriting the AOF file even if the percentage increase
 is reached but it is still pretty small.
基本大小和当前大小做比较。如果当前大小比指定比例的大小大，重写会触发。你也需要为将要被重写的aof文件指定一个小的尺寸，这对避免重写aof文件是有用的，即使达到了百分比的增长，但是它依然是很小的。
 Specify a percentage of zero in order to disable the automatic AOF
指定百分比为0，来禁用自动aof
 rewrite feature.
重写特性

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

 An AOF file may be found to be truncated at the end during the Redis
 startup process, when the AOF data gets loaded back into memory.
 This may happen when the system where Redis is running
 crashes, especially when an ext4 filesystem is mounted without the
 data=ordered option (however this can't happen when Redis itself
 crashes or aborts but the operating system still works correctly).
aof文件可能会被发现被截取在末尾，在redis启动程序过程中，当aof数据装载进了内存中。
在Redis启动过程中，当AOF数据被加载回内存时，可能会发现一个AOF文件在末尾被截断。
这可能发生，当redis正在运行的系统崩溃时，特别是当一个没有data=ordered选项的ext4的文件系统被挂载时（然而，当redis自身崩溃或者中断，而操作系统仍然正确的工作时不会发生）。
 Redis can either exit with an error when this happens, or load as much
 data as possible (the default now) and start if the AOF file is found
 to be truncated at the end. The following option controls this behavior.
当这发生时，redis可以产生一个错误并退出，或者加载尽可能多的数据（默认的），并且在aof文件被发现在结尾被截断时启动。接下来的这些选项控制了这些行为。
 If aof-load-truncated is set to yes, a truncated AOF file is loaded and
 the Redis server starts emitting a log to inform the user of the event.
 Otherwise if the option is set to no, the server aborts with an error
 and refuses to start. When the option is set to no, the user requires
 to fix the AOF file using the "redis-check-aof" utility before to restart
 the server.
如果aof-加载-截断被设置为yes，一个截断的aof文件被加载，redis服务器开始发出一个日志，来提醒用户这个事件。
否则，如果选项设置为no，服务将会和一个错误一起中断，并且拒绝启动。当选项设置为no时，用户需要在重启这个服务之前使用redis-检查-aof工具去修复这个aof文件。
 Note that if the AOF file will be found to be corrupted in the middle
 the server will still exit with an error. This option only applies when
 Redis will try to read more data from the AOF file but not enough bytes
 will be found.
注意，如果aof文件被发现在中间被损坏，服务器将仍然和一个错误一起终止。这个选项仅仅当redis将尝试从aof文件读更多的数据，但是没有更多的字节将被发现时应用。
aof-load-truncated yes

 LUA SCRIPTING  
LUA脚本scripting    
 Max execution time of a Lua script in milliseconds.
以毫秒计的lua脚本的最大执行时间
 If the maximum execution time is reached Redis will log that a script is
 still in execution after the maximum allowed time and will start to
 reply to queries with an error.
如果最大执行时间到达了，redis将记录，在最大允许时间之后一个脚本将仍然在执行中，将开始回复一个错误。
如果达到了最大执行时间，Redis将在最大允许时间之后记录脚本仍在执行，并将开始以错误的方式回复查询。
 When a long running script exceeds the maximum execution time only the
 SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be
 used to stop a script that did not yet called write commands. The second
 is the only way to shut down the server in the case a write command was
 already issued by the script but the user doesn't want to wait for the natural
 termination of the script.
当长的运行脚本超过了最大执行时间，只有script kill和shutdown nosave命令可以使用。第一个命令可以用来停止一个还没有调用写命令的脚本。第二个命令，在写命令已经被脚本处理，但是用户不想等待脚本自然终止时，终止服务是唯一的的办法。
当长时间运行的脚本超过最大执行时间时，只有脚本KILL和SHUTDOWN NOSAVE命令可用。
 Set it to 0 or a negative value for unlimited execution without warnings.
将它设置为0，或者一个负数来不限制执行，且没有警告信息。
lua-time-limit 5000

 REDIS CLUSTER  
redis cluster集群
 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however
 in order to mark it as "mature" we need to wait for a non trivial percentage
 of users to deploy it in production.
警告处于实验中：redis集群被认为是稳定的代码，然而，在生产环境中，为了将它标记为“mature成熟”，我们需要等待一个，来延迟执行它
警告实验:Redis集群被认为是稳定的代码，但是为了将其标记为“成熟”，我们需要等待相当大比例的用户将其部署到生产环境中。
 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Normal Redis instances can't be part of a Redis Cluster; only nodes that are
 started as cluster nodes can. In order to start a Redis instance as a
 cluster node enable the cluster support uncommenting the following:
普通的redis实例不能作为redis集群的一部分。只有那些作为集群节点启动的可以。为了将redis实例作为一个集群的节点来启动，确保集群支持下面未注释的内容：（允许集群支持取消以下注释:）
 cluster-enabled yes
集群-启动

 Every cluster node has a cluster configuration file. This file is not
 intended to be edited by hand. It is created and updated by Redis nodes.
 Every Redis Cluster node requires a different cluster configuration file.
 Make sure that instances running in the same system do not have
 overlapping cluster configuration file names.
每一个集群节点都有一个集群的配置文件。这个文件没有打算手动的编辑。它被redis节点创建和更新。每一个redis集群几点需要一个不同的集群配置文件。确保在相同的系统中运行的实例没有可以覆盖的（重叠的）集群配置文件名称。
 cluster-config-file nodes-6379.conf
集群-配置-文件
 Cluster node timeout is the amount of milliseconds a node must be unreachable
 for it to be considered in failure state.
集群节点超时是指节点在故障状态下必须无法到达的毫秒数。其他大多数内部时间限制是多个节点超时。
 Most other internal time limits are multiple of the node timeout.
集群节点超时时间是毫秒数，节点必须是不能到达的，被认为是处于失败的状态。大多数其它内部的时间限制是多个节点超时时间。
 cluster-node-timeout 15000
集群-节点-超时

 A slave of a failing master will avoid to start a failover if its data
 looks too old.
如果数据看起来时间很久了，一个失败的主库的从库将避免启动（失败主服务器的从属节点将避免启动故障转移）
 There is no simple way for a slave to actually have a exact measure of
 its "data age", so the following two checks are performed:
对于从库没有简单的方式来对它的“数据年龄”实际地准确的测量，因此跟着的两个选择被执行了：
 1) If there are multiple slaves able to failover, they exchange messages
    in order to try to give an advantage to the slave with the best
    replication offset (more data from the master processed).
    Slaves will try to get their rank by offset, and apply to the start
    of the failover a delay proportional to their rank.
如果有多个从库可以进行故障转移，它们交换信息，为了试图以给从库一个最好的主从复制偏移（更多的来自主程序处理过的数据）。
从库将尝试通过偏移量来获得它们的顺序（等级），并且应用于一个对它们顺序延迟故障转移的开启。（并对故障转移的开始应用与他们等级成比例的延迟）
如果有多个可以进行故障转移的从服务器，那么它们会交换消息，以便尝试以最佳的复制偏移量(主服务器处理的更多数据)为从服务器提供优势。
 2) Every single slave computes the time of the last interaction with
    its master. This can be the last ping or command received (if the master
    is still in the "connected" state), or the time that elapsed since the
    disconnection with the master (if the replication link is currently down).
    If the last interaction is too old, the slave will not try to failover
    at all.
每一个单独的从库计算最后和它的主库交互的时间。这个时间可以是最后一次脉冲或者命令接收（如果主库仍然处于已连接的状态），或者自从和主库失去连接以来消逝的时间（如果主从复制连接当前是停止的情况）。
如果最后一次交互太久了，从库将不再尝试故障转移。
 The point "2" can be tuned by user. Specifically a slave will not perform
 the failover if, since the last interaction with the master, the time
 elapsed is greater than:
第二点可以被用户调节。特别当一个从库不再执行故障转移时，自从库和主库最后一次交互时间起，消逝的时间比这个时间（节点-超时 * 从库-有效-因素）+ 回复-脉冲-从库-顺序要多：
   (node-timeout * slave-validity-factor) + repl-ping-slave-period

 So for example if node-timeout is 30 seconds, and the slave-validity-factor
 is 10, and assuming a default repl-ping-slave-period of 10 seconds, the
 slave will not try to failover if it was not able to talk with the master
 for longer than 310 seconds.
举个例子：如果节点-超时是30秒，从库-有效性-因素是10s，假设more的 回复-脉冲-从库-顺序是10s，从库将不再尝试故障转移，如果它和主库断开交互超过310秒时。
 A large slave-validity-factor may allow slaves with too old data to failover
 a master, while a too small value may prevent the cluster from being able to
 elect a slave at all.
大的从库-有效-因素允许从库使用较多的旧的数据进行故障转移，同时，一个很小的值会阻止集群选择从库。
 For maximum availability, it is possible to set the slave-validity-factor
 to a value of 0, which means, that slaves will always try to failover the
 master regardless of the last time they interacted with the master.
 (However they'll always try to apply a delay proportional to their
 offset rank).
为了最大的通用性，可以设置 从库-有效性-因素 的值为0，这意味着，从库将尝试对主库进行故障转移，不管它和主库之间最后的交互时间。
（然而，它们通常会尝试给它们的等级应用一个成比例的延迟）
 Zero is the only value able to guarantee that when all the partitions heal
 the cluster will always be able to continue.
0是唯一的能够担保（保证）的，当所有的分区恢复时，集群始终能够继续的值。
0是唯一能够保证当所有分区恢复时集群将始终能够继续的值。
 cluster-slave-validity-factor 10
集群-从库-有效性-因素

 Cluster slaves are able to migrate to orphaned masters, that are masters
 that are left without working slaves. This improves the cluster ability
 to resist to failures as otherwise an orphaned master can't be failed over
 in case of failure if it has no working slaves.
集群从库能够迁移为孤立的主库，这个主库没有从库就可以生存。这增加了集群抵制故障的能力，一个孤立的主库在故障的情况下不会被故障转移，如果它没有处于工作状态的从库。
 Slaves migrate to orphaned masters only if there are still at least a
 given number of other working slaves for their old master. This number
 is the "migration barrier". A migration barrier of 1 means that a slave
 will migrate only if there is at least 1 other working slave for its master
 and so forth. It usually reflects the number of slaves you want for every
 master in your cluster.
从库迁移为孤立的主库，只在仍然有至少一个给予的数量时，这个数量是别的旧的主库的处于工作状态的从库的。这个数量是 "迁移屏障"。迁移屏障为1意为着，从库将只在至少1个别的主库的工作中的从库或者更多时迁移。通常反应出你想要为集群中的主库设置的从库的数量。
只有当至少有一定数量的其他奴隶为他们的老主人工作时，奴隶才会迁移到孤家寡人的主人那里。这个数字就是“迁移障碍”。1的迁移障碍意味着一个奴隶只有在他的主人至少有一个其他的工作奴隶时才会迁移，以此类推。它通常反映了集群中每个主服务器所需的奴隶数量。
 Default is 1 (slaves migrate only if their masters remain with at least
 one slave). To disable migration just set it to a very large value.
 A value of 0 can be set but is useful only for debugging and dangerous
 in production.
默认为1（从库只在它们的主库保持至少一个从库时进行迁移）。禁止迁移，只需设置为一个非常大的值。可以设为0，但是仅仅在调试时有用，在生产环境中是危险的。
 cluster-migration-barrier 1
集群-迁移-屏障 

 By default Redis Cluster nodes stop accepting queries if they detect there
 is at least an hash slot uncovered (no available node is serving it).
 This way if the cluster is partially down (for example a range of hash slots
 are no longer covered) all the cluster becomes, eventually, unavailable.
 It automatically returns available as soon as all the slots are covered again.
默认情况下，如果它们检查到了至少一个哈希插槽没有被覆盖（发现）时（没有可用的节点来服务它（为其提供服务）），redis集群节点会停止接受查询。
这种方式下，如果集群局部的停止了（例如：一列哈希槽不再覆盖），最终，所有的集群都变得不可用。一旦插槽被重新覆盖时就会自动返回为可用的状态。

默认情况下，如果Redis集群节点检测到至少有一个散列槽未被发现(没有可用节点为其提供服务)，那么它们将停止接受查询。
这样，如果集群部分关闭(例如不再覆盖一组散列槽)，那么所有集群最终都会变得不可用。一旦所有的插槽再次被覆盖，它就会自动返回。
 However sometimes you want the subset of the cluster which is working,
 to continue to accept queries for the part of the key space that is still
 covered. In order to do so, just set the cluster-require-full-coverage
 option to no.
然而，有时你想让正在工作的集群的子集，对那些仍然是覆盖的键空间的部分继续接受请求。为了这样做，只需设置 集群-接受-完全-覆盖 选项为no。
然而，有时您希望集群的子集继续工作，继续接受仍然覆盖的关键空间部分的查询。
 cluster-require-full-coverage yes

 In order to setup your cluster make sure to read the documentation
 available at http://redis.io web site.
为了设置你的集群，确保去读可能在这个网站上的文档
 SLOW LOG 
慢日志
 The Redis Slow Log is a system to log queries that exceeded a specified
 execution time. The execution time does not include the I/O operations
 like talking with the client, sending the reply and so forth,
 but just the time needed to actually execute the command (this is the only
 stage of command execution where the thread is blocked and can not serve
 other requests in the meantime).
redis慢日志是一个记录那些超过指定执行时间的查询。这个执行时间没有包含 I/O 操作，比如和客户端建立连接，发送回复等等，而只是需要实际的执行命令的时间。（这是命令执行的唯一的阶段，在这个阶段中线程阻塞，并且同时不能服务其他的请求）

执行时间不包括I / O操作,比如与客户端,发送应答等等,但就实际执行命令所需的时间(这是唯一阶段命令执行的线程被阻塞,不能同时处理其他请求)。
 You can configure the slow log with two parameters: one tells Redis
 what is the execution time, in microseconds, to exceed in order for the
 command to get logged, and the other parameter is the length of the
 slow log. When a new command is logged the oldest one is removed from the
 queue of logged commands.
你可以使用两个参数来配置慢日志：一个告诉redis什么是执行时间，以微秒计，将要被记录的命令（为了让命令被记录），另一个参数是慢日志的长度。当一个新的命令被记录时，旧的那个命令被从日志命令队列中删除。

 The following time is expressed in microseconds, so 1000000 is equivalent
 to one second. Note that a negative number disables the slow log, while
 a value of zero forces the logging of every command.
这个时间是以微秒表达的，因此1000000是和1秒相等的。注意，负数会禁用慢查询日志，同时0会强制记录每一个命令。
slowlog-log-slower-than 10000

 There is no limit to this length. Just be aware that it will consume memory.
 You can reclaim memory used by the slow log with SLOWLOG RESET.
对这个长度没有限制。只需要警惕，它会消耗内存。你可以通过slowlog reset命令来释放被slow log占用的内存。
slowlog-max-len 128
慢日志-最大-长度
 LATENCY MONITOR 
latency monitor 延迟监控
 The Redis latency monitoring subsystem samples different operations
 at runtime in order to collect data related to possible sources of
 latency of a Redis instance.
redis延迟监控子系统采样不同的运行（操作），在运行时期，为了收集相关的redis实例延迟的可能的（潜在的）资源数据。
Redis延迟监视子系统在运行时采样不同的操作，以便收集与Redis实例的潜在延迟源相关的数据。
 Via the LATENCY command this information is available to the user that can
 print graphs and obtain reports.
通过延迟命令，这些信息对那些可以输入图像和获得报告的用户是可行的。
 The system only logs operations that were performed in a time equal or
 greater than the amount of milliseconds specified via the
 latency-monitor-threshold configuration directive. When its value is set
 to zero, the latency monitor is turned off.
系统只记录那些在一段时间内等于或者大于 经由 延迟-监控-临界值（入口，门槛）配置指令指定的毫秒数的被执行的操作。
系统只记录执行时间等于或大于通过lat- monitorthreshold配置指令指定的毫秒数的操作
当它的值被设置为0时，延迟监控会被关闭。
 By default latency monitoring is disabled since it is mostly not needed 
 if you don't have latency issues, and collecting data has a performance
 impact, that while very small, can be measured under big load. Latency
 monitoring can easily be enabled at runtime using the command
 "CONFIG SET latency-monitor-threshold <milliseconds>" if needed.
默认延迟监控是禁用的，因为如果你没有延迟的问题，大多数不需要，收集数据具有运行影响（消耗），这个消耗尽管非常小，在高负载情况下可以被测量。
如果需要的话，延迟监控可以容易的在运行期间被启用，使用命令 “配置 设置 延迟-监控-临界值 毫秒”
latency-monitor-threshold 0

 EVENT NOTIFICATION 
事件通知
 Redis can notify Pub/Sub clients about events happening in the key space.
 This feature is documented at http://redis.io/topics/notifications
redis可以通知 pub/sub 客户端 发生在键空间的事件。这个特性被记录在..
 For instance if keyspace events notification is enabled, and a client
 performs a DEL operation on key "foo" stored in the Database 0, two
 messages will be published via Pub/Sub:
对于实例来说，如果键空间事件通知是启用的，一个客户端在保存在数据库0的键“foo”上执行了一个DEL删除操作，两条消息将被通过 Pub/Sub 发布:
 PUBLISH __keyspace@0__:foo del
 PUBLISH __keyevent@0__:del foo

 It is possible to select the events that Redis will notify among a set
 of classes. Every class is identified by a single character:
可以选择事件，redis将在一个类的集合中进行通知。每一个类被一个单独的字符所标记：
可以在一组类中选择Redis将通知的事件。每个类都由一个字符标识:
  K     Keyspace events, published with __keyspace@<db>__ prefix. 键空间事件
  E     Keyevent events, published with __keyevent@<db>__ prefix.  键事件
  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ... 一般的命令（没有类型指定的） 像：删除，过期，重命名...
  $     String commands    字符串命令
  l     List commands  列表命令
  s     Set commands   集合命令
  h     Hash commands  哈希命令
  z     Sorted set commands    有序集命令
  x     Expired events (events generated every time a key expires) 过期事件（每当键过期时会生成这个事件）
  e     Evicted events (events generated when a key is evicted for maxmemory)  驱逐事件（当一个键由于最大内存被驱逐时会生成这个事件）
  A     Alias for g$lshzxe, so that the "AKE" string means all the events. 字符g的别名，因此ake字符表示所有的事件

  The "notify-keyspace-events" takes as argument a string that is composed
  of zero or multiple characters. The empty string means that notifications
  are disabled.
通知-键空间-事件 作为一个字符串参数，由0或者多个字符构成。空字符串意味着这个通知被禁用。
“notify-keyspace-events”将由0或多个字符组成的字符串作为参数
  Example: to enable list and generic events, from the point of view of the
           event name, use:
例子：启用列表和普通的事件，从事件名称的视角看，使用：
  notify-keyspace-events Elg
通知-键空间-事件 Elg
  Example 2: to get the stream of the expired keys subscribing to channel
             name __keyevent@0__:expired use:
例2： 获得过期键的流，订阅频道名__keyevent@0__ 使用：
  notify-keyspace-events Ex
通知-键空间-事件 Ex
  By default all notifications are disabled because most users don't need
  this feature and the feature has some overhead. Note that if you don't
  specify at least one of K or E, no events will be delivered.
默认所有的通知被禁用，因为大多数的用户不需要这个特性，并且这个特性有一些开销。注意，如果你没有指定K或者E中的至少一个，没有事件将被分发。
notify-keyspace-events ""

 ADVANCED CONFIG 
高级配置
 Hashes are encoded using a memory efficient data structure when they have a
 small number of entries, and the biggest entry does not exceed a given
 threshold. These thresholds can be configured using the following directives.
哈希使用内存有效的数据结构体编码，当有小数量的入口时，最大的入口不会超过给予的阈值。这些阈值可以使用以下的指令配置。
哈希是使用内存有效的数据结构进行编码的，当具有少量条目时，散列使用内存高效数据结构进行编码，并且最大条目不会超过给定的阈值。
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
哈希-最大-压缩表-条目
哈希-最大-压缩表-值

 Lists are also encoded in a special way to save a lot of space.
 The number of entries allowed per internal list node can be specified
 as a fixed maximum size or a maximum number of elements.
 For a fixed maximum size, use -5 through -1, meaning:
 -5: max size: 64 Kb  <-- not recommended for normal workloads
 -4: max size: 32 Kb  <-- not recommended
 -3: max size: 16 Kb  <-- probably not recommended
 -2: max size: 8 Kb   <-- good
 -1: max size: 4 Kb   <-- good
 Positive numbers mean store up to _exactly_ that number of elements
 per list node.
 The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
 but if your use case is unique, adjust the settings as necessary.
列表也被编码为一个指定的方式，来节省大量的空间。
条目的数量每一个内部列表节点可以被指示为一个固定最大值或者元素的最大数量。
每个内部列表节点允许的条目数可以指定为固定的最大大小或元素的最大数量。
对于一个固定的最大值，使用-5 到 -1，意思：
-5： 最大尺寸 64k 对于普通的工作量不推荐
不推荐
可能不推荐
好
积极的（正的）数意为保存到（存储） 精确的 每个列表节点元素的数量
正数意味着存储的元素的数量要精确到一定的数量
最大的运行配置通常为-2或者-1，但是如果你的使用情况十特殊的，以你所需来调整这个设置。
list-max-ziplist-size -2

 Lists may also be compressed.
 Compress depth is the number of quicklist ziplist nodes from *each* side of
 the list to *exclude* from compression.  The head and tail of the list
 are always uncompressed for fast push/pop operations.  Settings are:
 0: disable all list compression 禁用所有列表压缩
 1: depth 1 means "don't start compressing until after 1 node into the list,
    going from either the head or tail" 深度1意思是：不启动压缩，直到1节点进入到列表之后，来自于头或尾部
    So: [head]->node->node->...->node->[tail]
    [head], [tail] will always be uncompressed; inner nodes will compress. 头，尾总是不被压缩。内部的节点将被压缩。
 2: [head]->[next]->node->node->...->node->[prev]->[tail]
    2 here means: don't compress head or head->next or tail->prev or tail, 不压缩头或尾，但是压缩所有在它们之间的节点
    but compress all nodes between them.
 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]
 etc.等等
列表可能会被压缩。

压缩深度是quicklist ziplist节点的数量，来自于列表的每一边到压缩的排除。列表的头部和尾部总是没有被压缩，为了快速的push/pos操作。配置是：
压缩深度是列表的每个*侧的quicklist ziplist节点的数量，以排除*压缩。
list-compress-depth 0
列表压缩深度
 Sets have a special encoding in just one case: when a set is composed
 of just strings that happen to be integers in radix 10 in the range
 of 64 bit signed integers.
 The following configuration setting sets the limit in the size of the
 set in order to use this special memory saving encoding.
集合有一个特别的编码只有一种情况：当一个集合只被字符串组成时，发生整型在10在64位有符号整型。
集合在一种情况下有一个特殊的编码:当一个集合由刚好在基数为10的64位有符号整数范围内的整数组成时。
set-max-intset-entries 512
集合-最大-整数集合-条目

 Similarly to hashes and lists, sorted sets are also specially encoded in
 order to save a lot of space. This encoding is only used when the length and
 elements of a sorted set are below the following limits:
对于哈希和列表是相似的，有序集是特殊的编码，为了节省大量的空间。这个编码仅仅被用于当长度和有序集的元素数量是在下面的限制之下时：
zset-max-ziplist-entries 128
有序集-最大-压缩列表-条目
zset-max-ziplist-value 64
有序集-最大-压缩列表-值
 HyperLogLog sparse representation bytes limit. The limit includes the
 16 bytes header. When an HyperLogLog using the sparse representation crosses
 this limit, it is converted into the dense representation.
超语言稀疏表示字节限制。这个限制包括16个字节的标题。当使用稀疏表示的超loglog越过这个极限时，它就被转换为密集表示。
 A value greater than 16000 is totally useless, since at that point the
 dense representation is more memory efficient.
比16000大的值是完全无用的，因为在这种情况下，密度表示是更加内存有效的。
 The suggested value is ~ 3000 in order to have the benefits of
 the space efficient encoding without slowing down too much PFADD,
 which is O(N) with the sparse encoding. The value can be raised to
 ~ 10000 when CPU is not a concern, but space is, and the data set is
 composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
建议值为3000，以便从空间有效性获益，编码不会太多的减缓pfadd，它是稀疏编码的。这个值可以提升为10000，当cpu不是一个考虑的事，但是空间是时，数据集被构造为使用0-15000范围基数的许多基数统计
hll-sparse-max-bytes 3000
hll-稀疏-最大-字节
 Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
 order to help rehashing the main Redis hash table (the one mapping top-level
 keys to values). The hash table implementation Redis uses (see dict.c)
 performs a lazy rehashing: the more operation you run into a hash table
 that is rehashing, the more rehashing "steps" are performed, so if the
 server is idle the rehashing is never complete and some more memory is used
 by the hash table.
动态的重复哈希，使用1毫秒每100毫秒cpu时间，以便帮助重复哈希主要的redis哈希表（最高-等级键到值的映射的表）。哈希表实现redis用法（看dict.c）执行一个懒惰的重复哈希：在一个正在重哈希的哈希表中运行越多的操作，越多的重复哈希‘步骤“被执行，因此，如果服务器是闲置的，重哈希从来不会完成，一些更多的内存被哈希表所使用。

哈希表实现复述,使用(见dict.c)执行一个懒惰改作:操作越多改作遇到一个哈希表,越改作“步骤”执行,如果服务器空闲时再处理就不算完整和一些更多的内存使用哈希表。
 The default is to use this millisecond 10 times every second in order to
 actively rehash the main dictionaries, freeing memory when possible.
默认使用10毫秒每秒，以便动态的重哈希主要的字典，当可能时释放内存。
 If unsure:
 use "activerehashing no" if you have hard latency requirements and it is
 not a good thing in your environment that Redis can reply from time to time
 to queries with 2 milliseconds delay.
如果不确定：
使用 动态哈希 不 如果你有硬延迟的需求，在你的环境中这样做不是一个好的事，redis可以以2毫秒的延迟回复给查询每时每刻。
如果您有硬延迟需求，并且在您的环境中，Redis可以不时地以2毫秒的延迟回复查询，那么请使用“activerehash no”。
 use "activerehashing yes" if you don't have such hard requirements but
 want to free memory asap when possible.
使用 yes ，如果你没有这样的硬需求，但是想要尽快的释放内存当可能时。
activerehashing yes

 The client output buffer limits can be used to force disconnection of clients
 that are not reading data from the server fast enough for some reason (a
 common reason is that a Pub/Sub client can't consume messages as fast as the
 publisher can produce them).
客户端输出缓冲限制可以被用于强制客户端断开连接，那些由于一些原因没有从服务器足够快的读数据的客户端，（一个普遍的原因是，Pub/Sub 客户端不能和发布者生产它们一样快的消费消息）。
客户端输出缓冲区限制可用于强制断开由于某些原因而无法足够快地从服务器读取数据的客户端(一个常见的原因是，发布/子客户端不能像发布服务器生成消息那样快地使用消息)
 The limit can be set differently for the three different classes of clients:
这个限制可以被不同的设置为3个不同的客户端的类：
 normal -> normal clients including MONITOR clients 普通 普通的客户端，包括监听客户端
 slave  -> slave clients   从客户端
 pubsub -> clients subscribed to at least one pubsub channel or pattern    订阅了至少一个pubsub频道或者模式的客户端 客户至少订阅了一个pubsub通道或模式。

 The syntax of every client-output-buffer-limit directive is the following:
每一个 客户端-输出-缓冲-限制 指令的语法是在下面所示：
 client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
客户端-输出-缓冲-限制 类 固定的限制 软限制 软秒数
 A client is immediately disconnected once the hard limit is reached, or if
 the soft limit is reached and remains reached for the specified number of
 seconds (continuously).
一个客户端立即断开连接，一旦到达了硬限制，或者如果软限制到达，并且保持到达了指定数量的秒数（持续的）。
 So for instance if the hard limit is 32 megabytes and the soft limit is
 16 megabytes / 10 seconds, the client will get disconnected immediately
 if the size of the output buffers reach 32 megabytes, but will also get
 disconnected if the client reaches 16 megabytes and continuously overcomes
 the limit for 10 seconds.
因此，对于实例来说，如果硬限制是32百万字节，软限制是16百万字节/10秒。客户端将立刻断开连接，如果输出缓冲到达了32百万字节，如果客户端到达了16百万字节，并且持续超过了10s的限制，也会断开连接。
 By default normal clients are not limited because they don't receive data
 without asking (in a push way), but just after a request, so only
 asynchronous clients may create a scenario where data is requested faster
 than it can read.
默认普通的客户端没有限制，因为，它们在没有请求时（以一个推送的方式）不会接受数据，而是只在一个请求过后，只有异步的客户端可能创建一个场景，数据比读的速度更快的被请求。
 Instead there is a default limit for pubsub and slave clients, since
 subscribers and slaves receive data in a push fashion.
想反，对于pubsub发布订阅和从客户端有一个默认的限制，因为，订阅者和从库是以推送的形式接收数据。
 Both the hard or the soft limit can be disabled by setting them to zero.
将他们分别设置为0，硬和软限制都可以被禁用。
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
客户端-输出-缓冲-限制

 Redis calls an internal function to perform many background tasks, like
 closing connections of clients in timeout, purging expired keys that are
 never requested, and so forth.
redis调用一个内部的函数，来运行许多后台任务，像在客户端超时后关闭连接，清楚那些永远不会再被请求的键，等等。
 Not all tasks are performed with the same frequency, but Redis checks for
 tasks to perform according to the specified "hz" value.
不是所有的任务都被以相同的频率执行，而是redis选择任务，依据指定的hz值，来执行。
 By default "hz" is set to 10. Raising the value will use more CPU when
 Redis is idle, but at the same time will make Redis more responsive when
 there are many keys expiring at the same time, and timeouts may be
 handled with more precision.
默认，hz被设置为10。增加这个值，当redis是限制时将使用更多的CPU，但是，同时当有许多键在相同时间过期时，将使redis更加的响应性（敏感的 ），超时可以被更精确的解决。
 The range is between 1 and 500, however a value over 100 is usually not
 a good idea. Most users should use the default of 10 and raise this up to
 100 only in environments where very low latency is required.
范围是1和500之间，然而，值超过100通常不是一个好主意。大多数的用户应该使用默认值10，仅仅在需要非常小的延迟的环境中升到100.
hz 10

 When a child rewrites the AOF file, if the following option is enabled
 the file will be fsync-ed every 32 MB of data generated. This is useful
 in order to commit the file to the disk more incrementally and avoid
 big latency spikes.
当一个子进程重写AOF只追加文件时，下面的选项被启用，文件将被同步每生成的数据的32mb。这对于更递增的提交文件到硬盘，避免大的延迟发生是有效的。
当一个子文件重写AOF文件时，如果启用以下选项，则每生成32 MB的数据就对该文件进行一次fsync-ed。这是非常有用的，以便更增量地将文件提交到磁盘，并避免出现大延迟峰值。
aof-rewrite-incremental-fsync yes
aof-重写-递增的-文件同步

 redis启动日志
```
21832:M 23 Jul 11:40:34.278  User requested shutdown...
21832:M 23 Jul 11:40:34.278 * Saving the final RDB snapshot before exiting.
21832:M 23 Jul 11:40:34.282 * DB saved on disk
21832:M 23 Jul 11:40:34.282 * Removing the pid file.
21832:M 23 Jul 11:40:34.282  Redis is now ready to exit, bye bye...
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 3.2.0 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 21907
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

21907:M 23 Jul 11:40:34.289  WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
21907:M 23 Jul 11:40:34.289  Server started, Redis version 3.2.0
21907:M 23 Jul 11:40:34.289  WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
21907:M 23 Jul 11:40:34.289  WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
21907:M 23 Jul 11:40:34.289 * The server is now ready to accept connections on port 6379



21980:M 23 Jul 11:43:30.178  WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
21980:M 23 Jul 11:43:30.178  Server started, Redis version 3.2.0
21980:M 23 Jul 11:43:30.178  WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
21907:M 23 Jul 11:40:34.289  WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
21907:M 23 Jul 11:40:34.289 * The server is now ready to accept connections on port 6379
21907:M 23 Jul 11:43:23.321  User requested shutdown...
21907:M 23 Jul 11:43:23.321 * Saving the final RDB snapshot before exiting.
21907:M 23 Jul 11:43:23.328 * DB saved on disk
21907:M 23 Jul 11:43:23.328 * Removing the pid file.
21907:M 23 Jul 11:43:23.328  Redis is now ready to exit, bye bye...
21980:M 23 Jul 11:43:30.177 * Increased maximum number of open files to 10032 (it was originally set to 1024).
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 3.2.0 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 21980
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

21980:M 23 Jul 11:43:30.178  WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
21980:M 23 Jul 11:43:30.178  Server started, Redis version 3.2.0
21980:M 23 Jul 11:43:30.178  WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
21980:M 23 Jul 11:43:30.178  WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
21980:M 23 Jul 11:43:30.178 * DB loaded from disk: 0.000 seconds


22127:M 23 Jul 11:46:02.696  User requested shutdown...
22127:M 23 Jul 11:46:02.696 * Saving the final RDB snapshot before exiting.
22127:M 23 Jul 11:46:02.701 * DB saved on disk
22127:M 23 Jul 11:46:02.701 * Removing the pid file.
22127:M 23 Jul 11:46:02.701  Redis is now ready to exit, bye bye...
22196:M 23 Jul 11:46:04.782 * Increased maximum number of open files to 10032 (it was originally set to 1024).
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 3.2.0 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 22196
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

22196:M 23 Jul 11:46:04.783  Server started, Redis version 3.2.0
22196:M 23 Jul 11:46:04.783  WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
22196:M 23 Jul 11:46:04.784  WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
22196:M 23 Jul 11:46:04.784 * DB loaded from disk: 0.000 seconds
22196:M 23 Jul 11:46:04.784 * The server is now ready to accept connections on port 6379
~                                                                                             
```


### 总结
1. 主从复制：分为两种方式，rdb方式，无盘方式   
2. RDB快照： 根据设置的规则来将DB数据库的数据保存在硬盘上，在redis启动时，将从改文件中恢复数据到redis中  
3. AOF  
4. 客户端输出缓冲限制 client-output-buffer-limit  

### 参考文献
[Redis内存回收:LRU算法](https://blog.csdn.net/zdy0_2004/article/details/44685615)