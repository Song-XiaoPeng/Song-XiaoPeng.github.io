# Redis configuration file example.
#
# Note that in order to read the configuration file, Redis must be
# started with the file path as first argument:
# 
注意，为了读配置文件，Redis在启动时必须把这个文件的路径作为第一个参数：
# ./redis-server /path/to/redis.conf

# Note on units: when memory size is needed, it is possible to specify
# it in the usual form of 1k 5GB 4M and so forth:
# 注意这些单元：当需要内存大小时，可以将它指定为1k 5GB 4M等通常的格式，如下所示：
# 1k => 1000 bytes
# 1kb => 1024 bytes
# 1m => 1000000 bytes
# 1mb => 1024*1024 bytes
# 1g => 1000000000 bytes
# 1gb => 1024*1024*1024 bytes
#
# units are case insensitive so 1GB 1Gb 1gB are all the same.
单元是大小写不敏感的，所以1Gb和1gb是一样的。
################################## INCLUDES ###################################
includes包含文件
# Include one or more other config files here.  This is useful if you
# have a standard template that goes to all Redis servers but also need
# to customize a few per-server settings.  Include files can include
# other files, so use this wisely.
在这里包含一个或更多的其它的配置文件。如果你有一个标准模板的话，这是有用的，这个模板转到（定位）所有的Redis服务器，这些服务器也需要定义一些新的单一的服务器设置。包含文件可以包含其他的文件，所以明智的使用它们。
#
# Notice option "include" won't be rewritten by command "CONFIG REWRITE"
# from admin or Redis Sentinel. Since Redis always uses the last processed
# line as value of a configuration directive, you'd better put includes
# at the beginning of this file to avoid overwriting config change at runtime.
注意选项 include 不会被来自管理员或者redis集群的 "CONFIG REWRITE" 命令重写。因为Redis使用最后的进程线作为一个配置指令的值，你最好把includes放在这个文件的开始处，避免在运行时候覆盖改变配置。
由于Redis总是使用最后处理过的行作为配置指令的值，所以最好在这个文件的开头添加include，以避免在运行时覆盖配置更改。
#
# If instead you are interested in using includes to override configuration
# options, it is better to use include as the last line.
# 如果有兴趣使用includes覆盖一个配置选项，最好在最后一行使用include。

# include /path/to/local.conf
# include /path/to/other.conf

################################## NETWORK #####################################
网络
# By default, if no "bind" configuration directive is specified, Redis listens
# for connections from all the network interfaces available on the server.
# It is possible to listen to just one or multiple selected interfaces using
# the "bind" configuration directive, followed by one or more IP addresses.
# 默认情况下，如果没有指定bind配置指令，Redis从这台服务器上所有可能的网络接口中监听连接。
  可以使用bind配置指令监听仅仅一个或多个选定的接口，和面跟着一个或多个IP地址。
# Examples:
#
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1 ::1
#
# ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the
# internet, binding to all the interfaces is dangerous and will expose the
# instance to everybody on the internet. So by default we uncomment the
# following bind directive, that will force Redis to listen only into
# the IPv4 lookback interface address (this means Redis will be able to
# accept connections only from clients running into the same computer it
# is running).
# 
如果电脑正在运行Redis是直接的暴漏给互联网的，绑定所有的接口是危险的，将会把这个实例暴露给互联网上的每一个人。因此，默认我们取消注释下面的邦定指令，它将强制Redis仅仅去监听IPv4贿赂接口地址（这意味着redis将只能接受运行在同一台正在运行的计算机上的客户端的请求）

# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
# JUST COMMENT THE FOLLOWING LINE.
如果你确定你想让你的实例监听所有的接口，只需要注释下面的这一行。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bind 127.0.0.1

# Protected mode is a layer of security protection, in order to avoid that
# Redis instances left open on the internet are accessed and exploited.
# 
保护模式是一层安全守卫，为了避免redis实例在已授权的互联网上开启。
保护模式是一层安全保护，以避免在internet上打开的Redis实例被访问和利用。
# When protected mode is on and if:
#
当保护模式启动时，如果
# 1) The server is not binding explicitly to a set of addresses using the
#    "bind" directive.
服务器没有使用bind指令精确的绑定一个地址的集合。
# 2) No password is configured.
没有配置密码
#
# The server only accepts connections from clients connecting from the
# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain
# sockets.
#
服务器仅仅接受来自于IPv4和IPv6回路地址127.0.0.1 或 ::1的客户端的请求，和来自于Unix域名套接字。
# By default protected mode is enabled. You should disable it only if
# you are sure you want clients from other hosts to connect to Redis
# even if no authentication is configured, nor a specific set of interfaces
# are explicitly listed using the "bind" directive.
默认情况下，安全模式是被启用的。仅仅当你确定你想要来自于其它主机的客户端去连接Redis，即使没有配置权限，并且没有一个指定的精确的使用bind指令监听接口集合，你应该禁用它
启用默认保护模式。只有当您确定您希望其他主机的客户端连接到Redis时，您才应该禁用它，即使没有配置身份验证，也没有使用“bind”指令显式列出特定的接口集。
protected-mode yes

# Accept connections on the specified port, default is 6379 (IANA #815344).
# If port 0 is specified Redis will not listen on a TCP socket.
接收在指定的端口上的连接，默认是6379，如果端口指定的是0，redis将不监听TCP套接字

port 6379

# TCP listen() backlog.
#
TCP监听储备（积累，压力）
# In high requests-per-second environments you need an high backlog in order
# to avoid slow clients connections issues. Note that the Linux kernel
# will silently truncate it to the value of /proc/sys/net/core/somaxconn so
# make sure to raise both the value of somaxconn and tcp_max_syn_backlog
# in order to get the desired effect.
在高的每秒请求环境下，你需要一个高的压力，避免缓慢的客户端连接问题。注意，linux内核将安静的将它截断为/proc/sys/net/core/somaxconn的值，因此，确保同时增加somaxconn和tcp_max_syn_backlog的值，去获得期望的影响。
在每秒请求数高的环境中，您需要一个高待办事项列表，以避免客户机连接速度慢的问题。确保同时提高somaxconn和tcp_max_syn_backlog的值，以获得所需的效果。
tcp-backlog 511

# Unix socket.
#
unix套接字
# Specify the path for the Unix socket that will be used to listen for
# incoming connections. There is no default, so Redis will not listen
# on a unix socket when not specified.
#
为unix套接字指定路径，将被用于监听即将到来的连接。没有默认值，因此当没有指定时，redis将不去监听unix套接字
# unixsocket /tmp/redis.sock
# unixsocketperm 700

# Close the connection after a client is idle for N seconds (0 to disable)
在客户端闲置N秒时候关闭连接，0时禁用。
timeout 0

# TCP keepalive.
TCP长连接
#
# If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence
# of communication. This is useful for two reasons:
#
如果不是0，在沟通缺少时使用SO_KEEPALIVE向客户端发送TCP ACKS。有两个原因说明这是有用的：
如果非零，则使用SO_KEEPALIVE在没有通信的情况下将TCP报价单发送给客户端。这之所以有用，有两个原因:
# 1) Detect dead peers.
# 2) Take the connection alive from the point of view of network
    equipment in the middle.
侦测死的对等点。
从在中间的网络设备视口中使连接活的。
从中间的网络设备的角度来看，动态连接。
#
# On Linux, the specified value (in seconds) is the period used to send ACKs.
# Note that to close the connection the double of the time is needed.
# On other kernels the period depends on the kernel configuration.
#
在linux中，指定的值是（按秒）是顺序的发送ACK。注意，关闭双的连接是需要的。
在别的内核中，周期依赖于内核的配置

指定的值(以秒为单位)是用于发送ack的周期。注意，要关闭连接，需要双倍的时间。
# A reasonable value for this option is 60 seconds.
这个配置的一个合理的值是60秒。
tcp-keepalive 0

################################# GENERAL #####################################
通用
# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
默认，redis不会以守护进程的方式运行。如果你需要这样使用yes。
注意，reds在以守护进程方式运行时将在/var/run/redis.pid中写一个pid文件。
daemonize yes

# If you run Redis from upstart or systemd, Redis can interact with your
# supervision tree. Options:
#   supervised no      - no supervision interaction 没有监督交互
#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode 信号upstart通过将redis设置为sigstop模式
#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET 标志systemd通过写ready=1到$notify_socket
#   supervised auto    - detect upstart or systemd method based on  发现以UPSTART_JOB为环境变量为基础的upstart或者systemd的方法
#                        UPSTART_JOB or NOTIFY_SOCKET environment variables
# Note: these supervision methods only signal "process is ready."   注意：这些管理方法仅仅表示进程准备好了。
#       They do not enable continuous liveness pings back to your supervisor.   它们不确保连续的活跃脉冲返回给你的监督者
如果你从upstart或者system运行redis，Redis可以与您的监督树交互。选项:
supervised no

# If a pid file is specified, Redis writes it where specified at startup
# and removes it at exit.
如果一个pid文件被指定，redis将把它写到在启动时指定的地方，并且在结束（退出）时移动（删除）它。
#
# When the server runs non daemonized, no pid file is created if none is
# specified in the configuration. When the server is daemonized, the pid file
# is used even if not specified, defaulting to "/var/run/redis.pid".
当服务不是以守护进程方式运行时，如果在配置文件中没有指定则不会创建pid文件。当服务是以守护进程方式运行时，pid文件会被使用即使没有被指定，默认为"/var/run/redis.pid"

# Creating a pid file is best effort: if Redis is not able to create it
# nothing bad happens, the server will start and run normally.
创建一个pid文件是最好的，如果redis不能创建，服务器将正常的启动或者运行。
pidfile /var/run/redis.pid （Process Identification）进程代号

# Specify the server verbosity level.
# This can be one of:
# debug (a lot of information, useful for development/testing)  调试（大量的信息，对于开发和测试是有用的）
# verbose (many rarely useful info, but not a mess like the debug level) 冗长（许多很少有用的信息，但是不像调试模式那么多）
# notice (moderately verbose, what you want in production probably) 注意（适度的冗长，在生产环境中你最可能想要的）
# warning (only very important / critical messages are logged)  警告（只有非常重要、危险的消息被记录）
指定服务器冗长等级
可以是下面中的其一：
loglevel notice

# Specify the log file name. Also the empty string can be used to force
# Redis to log on the standard output. Note that if you use standard
# output for logging but daemonize, logs will be sent to /dev/null
指定日志文件名称。空的字符串也可以使用，强制redis在标准输出上记录。注意，如果你使用标准输出来记录而不是守护进程方式，日志将被发送到/dev/null
logfile "/var/log/redis.log"

# To enable logging to the system logger, just set 'syslog-enabled' to yes,
# and optionally update the other syslog parameters to suit your needs.
# syslog-enabled no
确保记录到系统日志管理者中， 只需设置为yes，可选择的更新别的syslog参数来适应你的需求。

# Specify the syslog identity.
# syslog-ident redis
指定syslog身份

# Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
# syslog-facility local0
指定syslog设备。必须是user或者LOCAL0-LOCAL7之间

# Set the number of databases. The default database is DB 0, you can select
# a different one on a per-connection basis using SELECT <dbid> where
# dbid is a number between 0 and 'databases'-1
设置数据库的号码。默认数据库是DB0，你可以使用SELECT dbid命令，dbid是一个0到-1的数字，来在每个连接基础上选择一个不同的号码。
databases 16

################################ SNAPSHOTTING  ################################
快照
#
# Save the DB on disk:  在硬盘上保存DB数据库
#
#   save <seconds> <changes>    
#
#   Will save the DB if both the given number of seconds and the given 
#   number of write operations against the DB occurred.
将保存DB，如果所给的秒数和所给的写操作的数量和已存在的DB冲突了。
如果同时发生给定的秒数和给定的针对DB的写操作数，将保存DB。
#   In the example below the behaviour will be to save: 在下面的例子中行为将被保存
#   after 900 sec (15 min) if at least 1 key changed    在900秒之后，如果至少1个键改变
#   after 300 sec (5 min) if at least 10 keys changed   在300秒之后，如果至少10个键改变了
#   after 60 sec if at least 10000 keys changed         在60秒之后，如果至少10000个键改变了

#   Note: you can disable saving completely by commenting out all "save" lines.
注意：你可以完全的禁止保存，通过注释所有的save行
#   It is also possible to remove all the previously configured save
#   points by adding a save directive with a single empty string argument
#   like in the following example:
也可以删除所有之前定义的save点，通过添加一个单独的空字符串参数的save指令，像之后的这个例子一样：
#   save ""

save 900 1
save 300 10
save 60 10000

# By default Redis will stop accepting writes if RDB snapshots are enabled
# (at least one save point) and the latest background save failed.
# This will make the user aware (in a hard way) that data is not persisting
# on disk properly, otherwise chances are that no one will notice and some
# disaster will happen.
#
# If the background saving process will start working again Redis will
# automatically allow writes again.
#
# However if you have setup your proper monitoring of the Redis server
# and persistence, you may want to disable this feature so that Redis will
# continue to work as usual even if there are problems with disk,
# permissions, and so forth.
默认情况下，如果RDB快照是起作用的（至少一个save点）和最后的后台保存失败了，那么redis将停止接受写操作。
这将让用户意识到（一个艰难的方式）数据没有合适的存留在硬盘上，否则没有人将注意到这个可能性，一些灾难将会发生。
）数据没有合适的存留在硬盘上，否则没有人将注意到这个可能性，一些灾难将会发生。

如果后台保存进程将再一次的开始工作，redis将再一次自动的允许写。

然而，如果你设置了你的合适的redis服务器和保存的配置，你可能想去禁用这个特性，这样redis将继续正常的工作，即使硬盘有一些问题，权限，等等。

stop-writes-on-bgsave-error yes

# Compress string objects using LZF when dump .rdb databases?
# For default that's set to 'yes' as it's almost always a win.
# If you want to save some CPU in the saving child set it to 'no' but
# the dataset will likely be bigger if you have compressible values or keys.
当导出rdb数据库时使用LZF压缩字符对象吗？
默认它被设置为yes
如果你想要在save子进程中保存一些CPU，将它设置为no，但是如果你有可压缩的值或键，数据集可能会变的更大。
rdbcompression yes

# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
# This makes the format more resistant to corruption but there is a performance
# hit to pay (around 10%) when saving and loading RDB files, so you can disable it
# for maximum performances.
#
# RDB files created with checksum disabled have a checksum of zero that will
# tell the loading code to skip the check.
自RDB版本5以来，一个crc64的校验和放置在这个文件的末尾。
这使格式更不容易被破坏的，但是，当保存和加载RDB文件时，会有性能损失（在10%左右），因此你可以由于最大的运行而禁止它。

这使得这种格式更不容易损坏，但是在保存和加载RDB文件时，会有性能损失(大约10%)，因此您可以禁用它以获得最大性能。

RDB文件和校验和为0的禁用的校验和一起创建，将告诉加载的码来跳过检查。

禁用校验和创建的RDB文件的校验和为零，它将告诉加载代码跳过校验。

rdbchecksum yes

# The filename where to dump the DB
导出DB到哪个文件
在何处转储DB的文件名
dbfilename sone_dump.rdb

# The working directory.
#
# The DB will be written inside this directory, with the filename specified
# above using the 'dbfilename' configuration directive.
#
# The Append Only File will also be created inside this directory.
#
# Note that you must specify a directory here, not a file name.
工作目录
DB将和上面使用dbfilename配置指令指定的文件名一起被写到这个目录里面。
只有追加的文件也能够在这个目录里面创建。
注意你必须在这里指定一个目录，而不是文件名
dir ~/tmp

################################# REPLICATION #################################
replication 主从复制
# Master-Slave replication. Use slaveof to make a Redis instance a copy of
# another Redis server. A few things to understand ASAP about Redis replication.
#
主从复制，使用slaveof指令创建一个redis实例，这个实例是另一个redis服务的拷贝。一些东西有助于理解ASAP关于redis主从复制。
关于Redis复制，有几点需要尽快理解。
# 1) Redis replication is asynchronous, but you can configure a master to
#    stop accepting writes if it appears to be not connected with at least
#    a given number of slaves.
redis主从复制是异步的，但是你可以配置一个主服务器来终止接受写操作，如果主服务器似乎没有和至少一个给予数量的从服务器连接时。
# 2) Redis slaves are able to perform a partial resynchronization with the
#    master if the replication link is lost for a relatively small amount of
#    time. You may want to configure the replication backlog size (see the next
#    sections of this file) with a sensible value depending on your needs.
redis从服务器可以和主服务器执行一部分的重复同步，如果主从复制连接丢失一个相关的小数量的时间。你可能想要去使用一个你需要的明智的值来配置主从复制backlog（储备，积压）大小（看这个文件的下一段）
# 3) Replication is automatic and does not need user intervention. After a
#    network partition slaves automatically try to reconnect to masters
#    and resynchronize with them.
主从复制是自动的，并且不需要用户的介入。在网络部分从服务器自动的尝试重新连接主服务器和重新备份（同步）他们时。
在网络分区之后，从服务器自动尝试重新连接到主服务器并与它们重新同步
# slaveof <masterip> <masterport>

# If the master is password protected (using the "requirepass" configuration
# directive below) it is possible to tell the slave to authenticate before
# starting the replication synchronization process, otherwise the master will
# refuse the slave request.
#
# masterauth <master-password>
如果主服务器是密码保护的（使用requirepass配置指令在下面），告诉从服务器启动主从复制同步进程之前进行认证，否则主服务器将拒绝从服务器的请求
在启动复制同步进程之前，可以告诉奴隶进行身份验证，否则主将拒绝从属请求。
# When a slave loses its connection with the master, or when the replication
# is still in progress, the slave can act in two different ways:
#
# 1) if slave-serve-stale-data is set to 'yes' (the default) the slave will
#    still reply to client requests, possibly with out of date data, or the
#    data set may just be empty if this is the first synchronization.
#
# 2) if slave-serve-stale-data is set to 'no' the slave will reply with
#    an error "SYNC with master in progress" to all the kind of commands
#    but to INFO and SLAVEOF.
#
当一个从库失去了和主库的连接，或者当主从复制仍在进行中，从服务器可以表现为两种不同的方式：

1 如果slave-serve-stale-data（从服务器旧数据）配置项设置为yes（默认），从服务器将回答客户端的请求，可能和超过日期的（过时的）数据，或者如果这是第一次同步数据集可能只是空的
2 如果slave-serve-stale-data设置为no，从服务器将答复给所有除了INFO和SLAVEOF命令一个错误“和主库的同步在进行中（同步主进程）”
slave-serve-stale-data yes

# You can configure a slave instance to accept writes or not. Writing against
# a slave instance may be useful to store some ephemeral data (because data
# written on a slave will be easily deleted after resync with the master) but
# may also cause problems if clients are writing to it because of a
# misconfiguration.
#
# Since Redis 2.6 by default slaves are read-only.
#
# Note: read only slaves are not designed to be exposed to untrusted clients
# on the internet. It's just a protection layer against misuse of the instance.
# Still a read only slave exports by default all the administrative commands
# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve
# security of read only slaves using 'rename-command' to shadow all the
# administrative / dangerous commands.
你可以配置一个从服务器实例来接受写操作或者不这样。写操作一个从服务实例对存储一些临时数据是有用的（因为在从数据库上被写的数据将会在和主库再同步之后容易的删除）但是如果客户端由于一个错误的配置正在写也可能引起问题。
对从实例进行写入对于存储一些临时数据可能很有用，因为写在从服务器上的数据在与主服务器重新同步后很容易被删除。但是，如果客户因为配置错误而写信给它，也可能会造成问题。

自从redis2.6起，默认的从服务器时只读的

注意：只读从服务器没有被设计为暴露给不真实的互联网上客户端。这只是对误用这个实例的一个保护。（它只是一个防止实例被滥用的保护层。）一个只读的从服务器默认导出所有的管理员的命令，例如：CONFIG，DEBUG，等等。你可以使用rename-command命令，隐藏所有的管理/危险的命令，提高只读从属的安全性。
在一定程度上，您可以通过使用“rename-command”对所有管理/危险的命令进行阴影来提高只读从属的安全性
slave-read-only yes

# Replication SYNC strategy: disk or socket.
# 主从服务同步策略：硬盘或者套接字
# -------------------------------------------------------
# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY diskless replication is experimental currently
# -------------------------------------------------------
# 警告：硬盘缺少的主从复制是 (无盘复制目前还处于实验阶段)
# New slaves and reconnecting slaves that are not able to continue the replication
# process just receiving differences, need to do what is called a "full
# synchronization". An RDB file is transmitted from the master to the slaves.
# The transmission can happen in two different ways:
新的从库和重新连接的从库不能够继续主从复制进程而是只能接收不同，需要去做被称作full synchronization 全同步的事。一个RDB文件被从主库传递给从库。
这个传递可以以两种不同的方式发生：
# 1) Disk-backed: The Redis master creates a new process that writes the RDB
#                 file on disk. Later the file is transferred by the parent
#                 process to the slaves incrementally.
硬盘支持的：redis主库创建一个新的进程，写入硬盘上的RDB文件。之后，这个文件被父进程递增地转变到从库。
# 2) Diskless: The Redis master creates a new process that directly writes the
#              RDB file to slave sockets, without touching the disk at all.
#
无盘的：redis主库创建一个新的进程，直接向从库的套接字写一个RDB文件，没有涉及（接触）到硬盘。
# With disk-backed replication, while the RDB file is generated, more slaves
# can be queued and served with the RDB file as soon as the current child producing
# the RDB file finishes its work. With diskless replication instead once    
# the transfer starts, new slaves arriving will be queued and a new transfer
# will start when the current one terminates.
#
硬盘支持的主从复制，会生成RDB文件，更多的从库可以和RDB文件，当当前子进程生产RDB文件结束时
使用磁盘支持的复制，当生成RDB文件时，只要生成RDB文件的当前子（文件）进程完成其工作，就可以对更多的从服务器进行排队并使用RDB文件。一旦传输开始，无盘主从复制替代，新的到达的从库将排队，当当前的传输结束后一个新的传输将开始。
使用无磁盘复制时，一旦传输开始，将会有新的从服务器进入队列，并且在当前从服务器传输终止时将开始新的传输。
# When diskless replication is used, the master waits a configurable amount of
# time (in seconds) before starting the transfer in the hope that multiple slaves
# will arrive and the transfer can be parallelized.
#
# With slow disks and fast (large bandwidth) networks, diskless replication
# works better.
当无盘主从复制被使用是，主服务器等待一个可设置数量的时间（秒数），在开始一个期望的传输之前，多个从服务器将到达，传输可以并行化。
当使用无磁盘复制时，主服务器在启动传输之前等待一个可配置的时间量(以秒为单位)，希望多个从服务器到达，并且传输可以并行化。

当使用慢的硬盘和快的网络（大的带宽）时，无盘主从复制更好的工作。
repl-diskless-sync no

# When diskless replication is enabled, it is possible to configure the delay
# the server waits in order to spawn the child that transfers the RDB via socket
# to the slaves.
#
# This is important since once the transfer starts, it is not possible to serve
# new slaves arriving, that will be queued for the next RDB transfer, so the server
# waits a delay in order to let more slaves arrive.
#
# The delay is specified in seconds, and by default is 5 seconds. To disable
# it entirely just set it to 0 seconds and the transfer will start ASAP.
当无盘主从复制是启用的，可以配置，服务器等待，传递RDB套接字给从库。

当启用无磁盘复制时，可以配置服务器等待的延迟，以便生成通过套接字将RDB传输到从服务器的子代。

一旦一个传输开始后，这是重要的，不会去服务新的到达的从库，它将进入队列来等待下一次的RDB传递，因此，服务器等待一个延迟来让更多的从库到达。

这个延迟被以秒为单位制定，默认是5秒。完全禁用它只需设置为0秒，传输将尽快开始。

repl-diskless-sync-delay 5

# Slaves send PINGs to server in a predefined interval. It's possible to change
# this interval with the repl_ping_slave_period option. The default value is 10
# seconds.
#
从库用一个预定义的时间间隔向服务器发送脉冲。可以使用repl_ping_slave_period选项改变这个时间间隔，。默认的值是10秒。
# repl-ping-slave-period 10

# The following option sets the replication timeout for:
#
下面的选项设置主从超时时间：
# 1) Bulk transfer I/O during SYNC, from the point of view of slave.
# 2) Master timeout from the point of view of slaves (data, pings).
# 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).
#
在同步的过程中，来自于从库的视角。在同步过程中，从从属的角度来看，批量传输I/O
主库超时来自于从库的视角。从奴隶的角度看的主超时(数据，ping)
从超时，从主库的角度来看（回复配置 ACK 脉冲）。
# It is important to make sure that this value is greater than the value
# specified for repl-ping-slave-period otherwise a timeout will be detected
# every time there is low traffic between the master and the slave.
#
重要的是要确保这个值比repl-ping-slave-period指定的值要大，否则一个超时将每个时间，在主和从之间是
每次主服务器和从服务器之间的通信流量较低时，都会检测到超时。
# repl-timeout 60

# Disable TCP_NODELAY on the slave socket after SYNC?
#
禁用从套接字上的TCP_不搁置，在同步之后？
# If you select "yes" Redis will use a smaller number of TCP packets and
# less bandwidth to send data to slaves. But this can add a delay for
# the data to appear on the slave side, up to 40 milliseconds with
# Linux kernels using a default configuration.
#
如果你选择了yes，redis将使用一个小的TCP包数量，更少的带宽来向从库发送数据。但是这可以为这个将要出现在从服务器这边的数据添加一个延迟，linux内核使用默认的配置会超过40毫秒。
# If you select "no" the delay for data to appear on the slave side will
# be reduced but more bandwidth will be used for replication.
#
如果你选择了no，出现在从服务器这边的延迟将减少，但是更多的带宽将被用作主从复制。
# By default we optimize for low latency, but in very high traffic conditions
# or when the master and slaves are many hops away, turning this to "yes" may
# be a good idea.
默认情况下，我们优化低的延迟，但是在非常高的流量状况下，或者当主和从有许多跳跃时（非常活跃时），将它转变为yes是一个好的主意。
repl-disable-tcp-nodelay no

# Set the replication backlog size. The backlog is a buffer that accumulates
# slave data when slaves are disconnected for some time, so that when a slave
# wants to reconnect again, often a full resync is not needed, but a partial
# resync is enough, just passing the portion of data the slave missed while
# disconnected.
#
设置主从复制储备大小。储备是一个缓冲，积累从数据，当从库失去连接一段时间时，因此，当一个从库想要重新连接时，通常一个完整的重新同步不需要，一个分步的重新同步是足够的，只需要在失去连接时传递从库丢失的那部分数据。
# The bigger the replication backlog, the longer the time the slave can be
# disconnected and later be able to perform a partial resynchronization.
主从复制储存的越大，从库可以被断开连接的时间越长，之后可以运行一个部分的重新同步。
复制待办事项列表越大，从服务器断开连接的时间就越长，之后就可以执行部分重新同步。
# The backlog is only allocated once there is at least a slave connected.
储存只允许，当至少一个从库被连接时。
只有在连接到至少一个从属节点时，才分配backlog。
# repl-backlog-size 1mb

# After a master has no longer connected slaves for some time, the backlog
# will be freed. The following option configures the amount of seconds that
# need to elapse, starting from the time the last slave disconnected, for
# the backlog buffer to be freed.
有时，在主库没有已连接的从库之后，储存（备份）将被释放。下面的选项为需要释放的备份缓存配置了需要消耗的秒数，这个时间从最后一个从库断开连接开始。
下面的选项将配置从最后一个从服务器断开连接开始需要经过的秒数，以便释放backlog缓冲区。
值0意味着永远不释放备份。
#
# repl-backlog-ttl 3600

# The slave priority is an integer number published by Redis in the INFO output.
# It is used by Redis Sentinel in order to select a slave to promote into a
# master if the master is no longer working correctly.
从库的优先权是一个整型的数字，是redis在info输出中发布的。
被用于redis哨兵，来选择一个从库来提升（升级为提升为）主库，如果主库不在正确的工作。
# A slave with a low priority number is considered better for promotion, so
# for instance if there are three slaves with priority 10, 100, 25 Sentinel will
# pick the one with priority 10, that is the lowest.
低优先权数字低的从库对于提升为主库被考虑（认为）为更好的，因此，对于实例来说，如果有三个从库，优先权为10，100，25，哨兵将选择那个优先权为10的，最低的那个。
一个低优先级的奴隶被认为更适合提升，所以如果有三个拥有优先级10,100,25sentinel的奴隶会选择优先级为10的奴隶，这是最低的。
# However a special priority of 0 marks the slave as not able to perform the
# role of master, so a slave with priority of 0 will never be selected by
# Redis Sentinel for promotion.
然而指定优先权0标示从库不能作为主库的角色运行，因此优先权为0的从库将从不会被redis哨兵选择作为提升。
# By default the priority is 100.
默认优先权是100。
slave-priority 100

# It is possible for a master to stop accepting writes if there are less than
# N slaves connected, having a lag less or equal than M seconds.
对于主库，可以停止接受写操作，如果少于n个从库连接，延迟小于或等于m秒。
# The N slaves need to be in "online" state.
这N个从库需要是在线的状态。
# The lag in seconds, that must be <= the specified value, is calculated from
# the last ping received from the slave, that is usually sent every second.
延迟以秒为单位，必须<=指定的值，从最后一次接收到从库的脉冲计算，通常每秒发送一次。
# This option does not GUARANTEE that N replicas will accept the write, but
# will limit the window of exposure for lost writes in case not enough slaves
# are available, to the specified number of seconds.
#这个配置不会guarantee授权，N个回复将接受写操作，但是由于失去写操作将限制暴露的窗口，在没有充足可用的从库时，指定的秒数。
此选项不保证N个副本将接受写操作，但如果没有足够的从服务器可用，则将丢失写的暴露窗口限制为指定的秒数。
# For example to require at least 3 slaves with a lag <= 10 seconds use:
例如，<=10秒的延迟来获得至少3个从库，使用这个配置：
# min-slaves-to-write 3
# min-slaves-max-lag 10
#
# Setting one or the other to 0 disables the feature.
设置一个或者另一个为0来禁用这项特性。
# By default min-slaves-to-write is set to 0 (feature disabled) and
# min-slaves-max-lag is set to 10.
默认最小从库写设置为0，禁用特性，最小从库最大延迟设置为10。

################################## SECURITY ###################################
安全
# Require clients to issue AUTH <PASSWORD> before processing any other
# commands.  This might be useful in environments in which you do not trust
# others with access to the host running redis-server.
#
需要客户端发出AUTH密码，在处理任何其它命令之前。在那些你不信任别人访问这台主机上运行的redis服务器的环境下，这可能是有用的。
这在不信任其他访问运行redis-server的主机的环境中可能很有用。
# This should stay commented out for backward compatibility and because most
# people do not need auth (e.g. they run their own servers).
#
应该保留注释，对于以后的兼容性（为了向后兼容），因为大多数人不需要认证（它们在自己的服务器上运行）。
# Warning: since Redis is pretty fast an outside user can try up to
# 150k passwords per second against a good box. This means that you should
# use a very strong password otherwise it will be very easy to break.
#
警告：因为redis是非常快的，外边的用户可以尝试每秒150k个密码攻击一个好的服务器。这意味着，你应该使用一个非常强壮的密码，否则它将会非常容易的被破坏。
requirepass shop

# Command renaming.
#
命令重命名
# It is possible to change the name of dangerous commands in a shared
# environment. For instance the CONFIG command may be renamed into something
# hard to guess so that it will still be available for internal-use tools
# but not available for general clients.
#
可以在一个共享的环境中改变危险命令的名字。例如config命令，可以被重命名为其它难以被踩到的名字，这样它对于内部使用工具来说仍然是可用的，但是对于普通的客户端来说就不能用了。
# Example:例子：
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# It is also possible to completely kill a command by renaming it into
# an empty string:
#
也可以完全取消一个命令，通过把它命名为空字符串：
# rename-command CONFIG ""
#
# Please note that changing the name of commands that are logged into the
# AOF file or transmitted to slaves may cause problems.
请注意：改变命令的名字，被记录到AOF文件中，或者传递到从库中会引发问题。
################################### LIMITS ####################################
限制
# Set the max number of connected clients at the same time. By default
# this limit is set to 10000 clients, however if the Redis server is not
# able to configure the process file limit to allow for the specified limit
# the max number of allowed clients is set to the current file limit
# minus 32 (as Redis reserves a few file descriptors for internal uses).
设置可同时连接的客户端的最大数量。默认，这个限制设置为10000个客户端，然而，如果redis服务器不能配置进程文件限制，来允许指定的限制，最大的允许连接客户端数量被设置为当前文件限制减去32（因为Redis保存一些新的文件描述者来作为内部使用）。
# Once the limit is reached Redis will close all the new connections sending
# an error 'max number of clients reached'.
一旦这个限制达到了，redis将会关闭所有的新的连接，并且会发送一个错误‘达到了最大数量的客户端限制’。
# maxclients 10000

# Don't use more memory than the specified amount of bytes.
# When the memory limit is reached Redis will try to remove keys
# according to the eviction policy selected (see maxmemory-policy).
#
不要使用超过指示数量字节的更多内存。
当内存限制达到了，redis将试图依据所选择的驱除政策（逐出策略）删除键。（看最大内存策略）
# If Redis can't remove keys according to the policy, or if the policy is
# set to 'noeviction', Redis will start to reply with errors to commands
# that would use more memory, like SET, LPUSH, and so on, and will continue
# to reply to read-only commands like GET.
如果redis不能依据策略删除键，或者，如果这个策略被设置为‘noeviction’（不驱逐），redis将开始回复错误给那些使用更多内存的命令，例如set，lpush，等等， 并且将继续回复只读的命令，比如GET。
# This option is usually useful when using Redis as an LRU cache, or to set
# a hard memory limit for an instance (using the 'noeviction' policy).
这个选项通常是有用的，当使用redis作为一个LRU缓存时，或者为一个实例设置一个困难的内存限制（使用不逐出策略）。设置实例的硬内存限制(使用“nostare tion”策略)时
# WARNING: If you have slaves attached to an instance with maxmemory on,
# the size of the output buffers needed to feed the slaves are subtracted
# from the used memory count, so that network problems / resyncs will
# not trigger a loop where keys are evicted, and in turn the output
# buffer of slaves is full with DELs of keys evicted triggering the deletion
# of more keys, and so forth until the database is completely emptied.
注意：如果你有从库依附于一个实例，同时开启了最大内存限制，需要供给从库的输出缓冲的大小是从已使用的内存数量中减去的，因此，网络问题/重新同步将不再触发一个键被逐出的循环，轮流的从库的输出缓存将填充为被驱逐键的DELs指令，触发更多键的删除，等等，直到数据库完全为空。
# In short... if you have slaves attached it is suggested that you set a lower
# limit for maxmemory so that there is some free RAM on the system for slave
# output buffers (but this is not needed if the policy is 'noeviction').
总之，如果你有附属的从库，建议你设置一个低的最大内存限制，这样有一些系统上的空闲的RAM（随机访问内存）来作为输出缓存。（但是如果策略是不驱逐的话，不需要这样）。
# maxmemory <bytes>

# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
# is reached. You can select among five behaviors:
#
最大内存策略：当到达最大内存时，redis将如何选择来删除什么。你可以选择这这5个之中的行为：
# volatile-lru -> remove the key with an expire set using an LRU algorithm  易失的-lru -> 使用一个LRU算法删除有过期集合的键
# allkeys-lru -> remove any key according to the LRU algorithm  所有的键-lru -> 依据LRU算法来删除任何一个键
# volatile-random -> remove a random key with an expire set     易失的-随机的 -> 使用过期集删除一个随机的键
# allkeys-random -> remove a random key, any key    所有键-随机 随机删除一个键，任何一个键
# volatile-ttl -> remove the key with the nearest expire time (minor TTL)   易失的-生存时间 使用最接近的过期时间删除键（小的生存时间）
# noeviction -> don't expire at all, just return an error on write operations   不驱逐 -- 不过期，只返回一个错误给写操作集。
1.volatile-lru:从设置了过期时间的数据集中，选择最近最久未使用的数据释放

2.allkeys-lru:从数据集中(包括设置过期时间以及未设置过期时间的数据集中)，选择最近最久未使用的数据释放

3.volatile-random:从设置了过期时间的数据集中，随机选择一个数据进行释放

4.allkeys-random:从数据集中(包括了设置过期时间以及未设置过期时间)随机选择一个数据进行入释放

5.volatile-ttl：从设置了过期时间的数据集中，选择马上就要过期的数据进行释放操作

6.noeviction：不删除任意数据(但redis还会根据引用计数器进行释放呦~),这时如果内存不够时，会直接返回错误
# Note: with any of the above policies, Redis will return an error on write
#       operations, when there are no suitable keys for eviction.
#
#       At the date of writing these commands are: set setnx setex append
#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
#       getset mset msetnx exec sort
注意：在任一个上面的策略中，redis将在写操作上返回一个错误，当没有合适的键驱逐时。
# The default is:
默认值是：
#
# maxmemory-policy noeviction
最大内存-策略 不驱逐

# LRU and minimal TTL algorithms are not precise algorithms but approximated
# algorithms (in order to save memory), so you can tune it for speed or
# accuracy. For default Redis will check five keys and pick the one that was
# used less recently, you can change the sample size using the following
# configuration directive.
LRU和最小的生存时间算法不是精确的算法，而是接近的（近似）算法（为了节省内存），所以你可以调整它的速度或精度。默认redis将检查5个键，选择最近被使用最少的一个，你可以使用下面的配置指令来改变这个实例值大小。
# The default of 5 produces good enough results. 10 Approximates very closely
# true LRU but costs a bit more CPU. 3 is very fast but not very accurate.
默认为5时可以产生足够好的结果。10近似于非常接近的真的LRU，但会花费一点CPU。3是非常快的，但是不是非常精确。
5的默认值产生了足够好的结果。10非常接近真实的LRU，但是需要多一点CPU。3是非常快，但不是很准确。
# maxmemory-samples 5 
最大内存-实例 5

############################## APPEND ONLY MODE ###############################
只追加模式
# By default Redis asynchronously dumps the dataset on disk. This mode is
# good enough in many applications, but an issue with the Redis process or
# a power outage may result into a few minutes of writes lost (depending on
# the configured save points).
默认redis异步的在硬盘上导出数据。这个模式在许多应用中是足够好的，但是，由于redis进程的问题或者断电可能导致几分钟的写丢失（依赖于已配置的保存点）。
但是，由于Redis进程的问题或断电，可能会导致几分钟的写入丢失。
# The Append Only File is an alternative persistence mode that provides
# much better durability. For instance using the default data fsync policy
# (see later in the config file) Redis can lose just one second of writes in a
# dramatic event like a server power outage, or a single write if something
# wrong with the Redis process itself happens, but the operating system is
# still running correctly.
只追加文件是一个供选择的（替代的）保存（持久性）模式，提供更好的耐久性。因为实例使用默认的数据fsync策略（稍后在配置文件中看到），redis会失去仅仅一秒的写操作，在一些戏剧性的事件中类似于服务器断电，或者如果redis进程自身发生的一些错误时的单一写，但是这个正在运行的系统仍然会正确的运行。

Append Only文件是另一种持久性模式，提供了更好的持久性。例如使用默认数据fsync策略配置文件中(见后)复述,可以失去只是一秒的写在一个戏剧性的事件像一个服务器断电,或一个写如果复述过程本身出了问题,但正确操作系统仍在运行。
# AOF and RDB persistence can be enabled at the same time without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the file
# with the better durability guarantees.
AOF和RDB持久化模式，可以同时没有问题的启用。如果AOF在启动时是开启的，那么redis将加载AOF，这个文件有更持久的保证。
# Please check http://redis.io/topics/persistence for more information.
选择来获得更多的信息。

appendonly no

# The name of the append only file (default: "appendonly.aof")
只追加文件的名字（默认：..）
appendfilename "appendonly.aof"

# The fsync() call tells the Operating System to actually write data on disk
# instead of waiting for more data in the output buffer. Some OS will really flush
# data on disk, some other OS will just try to do it ASAP.
fsync()调用，告诉操作系统在硬盘上实际地写数据，而不是等待在输出缓冲中的更多的数据。一些操作系统将真的刷出数据到磁盘上，另一些操作系统只试图尽快的做这件事。
# Redis supports three different modes:
redis支持三种不同的模式：
# no: don't fsync, just let the OS flush the data when it wants. Faster.
# always: fsync after every write to the append only log. Slow, Safest.
# everysec: fsync only one time every second. Compromise.
no不启用: 不启用fsync，让操作系统在它想要时刷出数据。更快。
always总是：fsync 在每次写操作到只追加日志后进行。慢，最安全。
everysec: fsync 每秒只一次。妥协。
# The default is "everysec", as that's usually the right compromise between
# speed and data safety. It's up to you to understand if you can relax this to
# "no" that will let the operating system flush the output buffer when
# it wants, for better performances (but if you can live with the idea of
# some data loss consider the default persistence mode that's snapshotting),
# or on the contrary, use "always" that's very slow but a bit safer than
# everysec.
默认是“每秒”，因为这是通常在速度和数据安全性之间正确的妥协。取决于你的理解，如果你可以设置为no，就会使操作系统在它想要时刷出输出缓存，为了更好的运行（但是如果你有这个想法，一些数据丢失默认的持久化模式是快照），或者相反的，使用“总是”,这是非常慢但是比每秒更安全一点。
(但是，如果您能够忍受某些数据丢失的想法，请考虑默认的持久性模式，即快照模式)
# More details please check the following article:
更详细的请选择下面的这篇文章：
# http://antirez.com/post/redis-persistence-demystified.html
#
# If unsure, use "everysec".
如果不确定，使用每秒

# appendfsync always
appendfsync everysec
# appendfsync no

# When the AOF fsync policy is set to always or everysec, and a background
# saving process (a background save or AOF log background rewriting) is
# performing a lot of I/O against the disk, in some Linux configurations
# Redis may block too long on the fsync() call. Note that there is no fix for
# this currently, as even performing fsync in a different thread will block
# our synchronous write(2) call.
当AOF fsync（文件同步）策略被设置为总是或者每秒时，并且后台的保存进程（后台保存或者只追加文件记录后台重写）会占用硬盘大量的I/O，在一些linux配置中，redis可能在fsync()调用时阻塞了太长。注意，目前对这个问题还没有解决方法，即使在不同的线程运行fsync也会阻塞我们同步的写调用。
当AOF fsync策略设置为总是或每秒钟，并且后台保存进程(后台保存或AOF日志背景重写)对磁盘执行大量I/O时，在某些Linux配置中，Redis可能会在fsync()调用中阻塞太长时间。
请注意，目前没有对此进行修复，因为即使在不同的线程中执行fsync也会阻塞我们的同步写(2)调用。
# In order to mitigate this problem it's possible to use the following option
# that will prevent fsync() from being called in the main process while a
# BGSAVE or BGREWRITEAOF is in progress.
为了解决这个问题，可以使用如下的选项，当bgsave或者bgrewriteaof在运行中时，这些选项将阻止fsync()在主进程中调用。
# This means that while another child is saving, the durability of Redis is
# the same as "appendfsync none". In practical terms, this means that it is
# possible to lose up to 30 seconds of log in the worst scenario (with the
# default Linux settings).
这意味着，在另一个子进程在保存时，redis的持久化和‘追加文件同步fsync 没有’相同。实际上，这意味着可能失去30秒的日志在最坏的场景中（使用默认的linux设置）。
实际上，这意味着在最坏的情况下(使用默认的Linux设置)，可能会丢失长达30秒的日志。
# If you have latency problems turn this to "yes". Otherwise leave it as
# "no" that is the safest pick from the point of view of durability.
如果你有延迟（潜伏，潜在因素，延迟，潜伏期）问题，将它转变为yes。否则让它为no，这是站在持久化视角的最安全的选择。
no-appendfsync-on-rewrite no

# Automatic rewrite of the append only file.
# Redis is able to automatically rewrite the log file implicitly calling
# BGREWRITEAOF when the AOF log size grows by the specified percentage.
自动重写只追加文件
redis能自动的重写日志文件，bgrewriteaof，当只追加写日志大小被指定的比例增长了。
当AOF日志大小以指定的百分比增长时，Redis能够自动重写隐式调用BGREWRITEAOF的日志文件。
# This is how it works: Redis remembers the size of the AOF file after the
# latest rewrite (if no rewrite has happened since the restart, the size of
# the AOF at startup is used).
这是它工作的方式：redis还记得只追加文件的大小，在最近一次的重写过后。（如果自重启过后还没有重写发生，那么在启动时只追加文件的大小被使用）。

# This base size is compared to the current size. If the current size is
# bigger than the specified percentage, the rewrite is triggered. Also
# you need to specify a minimal size for the AOF file to be rewritten, this
# is useful to avoid rewriting the AOF file even if the percentage increase
# is reached but it is still pretty small.
基本大小和当前大小做比较。如果当前大小比指定比例的大小大，重写会触发。你也需要为将要被重写的aof文件指定一个小的尺寸，这对避免重写aof文件是有用的，即使达到了百分比的增长，但是它依然是很小的。
# Specify a percentage of zero in order to disable the automatic AOF
指定百分比为0，来禁用自动aof
# rewrite feature.
重写特性

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# An AOF file may be found to be truncated at the end during the Redis
# startup process, when the AOF data gets loaded back into memory.
# This may happen when the system where Redis is running
# crashes, especially when an ext4 filesystem is mounted without the
# data=ordered option (however this can't happen when Redis itself
# crashes or aborts but the operating system still works correctly).
aof文件可能会被发现被截取在末尾，在redis启动程序过程中，当aof数据装载进了内存中。
在Redis启动过程中，当AOF数据被加载回内存时，可能会发现一个AOF文件在末尾被截断。
这可能发生，当redis正在运行的系统崩溃时，特别是当一个没有data=ordered选项的ext4的文件系统被挂载时（然而，当redis自身崩溃或者中断，而操作系统仍然正确的工作时不会发生）。
# Redis can either exit with an error when this happens, or load as much
# data as possible (the default now) and start if the AOF file is found
# to be truncated at the end. The following option controls this behavior.
当这发生时，redis可以产生一个错误并退出，或者加载尽可能多的数据（默认的），并且在aof文件被发现在结尾被截断时启动。接下来的这些选项控制了这些行为。
# If aof-load-truncated is set to yes, a truncated AOF file is loaded and
# the Redis server starts emitting a log to inform the user of the event.
# Otherwise if the option is set to no, the server aborts with an error
# and refuses to start. When the option is set to no, the user requires
# to fix the AOF file using the "redis-check-aof" utility before to restart
# the server.
如果aof-加载-截断被设置为yes，一个截断的aof文件被加载，redis服务器开始发出一个日志，来提醒用户这个事件。
否则，如果选项设置为no，服务将会和一个错误一起中断，并且拒绝启动。当选项设置为no时，用户需要在重启这个服务之前使用redis-检查-aof工具去修复这个aof文件。
# Note that if the AOF file will be found to be corrupted in the middle
# the server will still exit with an error. This option only applies when
# Redis will try to read more data from the AOF file but not enough bytes
# will be found.
注意，如果aof文件被发现在中间被损坏，服务器将仍然和一个错误一起终止。这个选项仅仅当redis将尝试从aof文件读更多的数据，但是没有更多的字节将被发现时应用。
aof-load-truncated yes

################################ LUA SCRIPTING  ###############################
LUA脚本scripting    
# Max execution time of a Lua script in milliseconds.
以毫秒计的lua脚本的最大执行时间
# If the maximum execution time is reached Redis will log that a script is
# still in execution after the maximum allowed time and will start to
# reply to queries with an error.
如果最大执行时间到达了，redis将记录，在最大允许时间之后一个脚本将仍然在执行中，将开始回复一个错误。
如果达到了最大执行时间，Redis将在最大允许时间之后记录脚本仍在执行，并将开始以错误的方式回复查询。
# When a long running script exceeds the maximum execution time only the
# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be
# used to stop a script that did not yet called write commands. The second
# is the only way to shut down the server in the case a write command was
# already issued by the script but the user doesn't want to wait for the natural
# termination of the script.
#
# Set it to 0 or a negative value for unlimited execution without warnings.
lua-time-limit 5000

################################ REDIS CLUSTER  ###############################
#
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however
# in order to mark it as "mature" we need to wait for a non trivial percentage
# of users to deploy it in production.
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
# Normal Redis instances can't be part of a Redis Cluster; only nodes that are
# started as cluster nodes can. In order to start a Redis instance as a
# cluster node enable the cluster support uncommenting the following:
#
# cluster-enabled yes

# Every cluster node has a cluster configuration file. This file is not
# intended to be edited by hand. It is created and updated by Redis nodes.
# Every Redis Cluster node requires a different cluster configuration file.
# Make sure that instances running in the same system do not have
# overlapping cluster configuration file names.
#
# cluster-config-file nodes-6379.conf

# Cluster node timeout is the amount of milliseconds a node must be unreachable
# for it to be considered in failure state.
# Most other internal time limits are multiple of the node timeout.
#
# cluster-node-timeout 15000

# A slave of a failing master will avoid to start a failover if its data
# looks too old.
#
# There is no simple way for a slave to actually have a exact measure of
# its "data age", so the following two checks are performed:
#
# 1) If there are multiple slaves able to failover, they exchange messages
#    in order to try to give an advantage to the slave with the best
#    replication offset (more data from the master processed).
#    Slaves will try to get their rank by offset, and apply to the start
#    of the failover a delay proportional to their rank.
#
# 2) Every single slave computes the time of the last interaction with
#    its master. This can be the last ping or command received (if the master
#    is still in the "connected" state), or the time that elapsed since the
#    disconnection with the master (if the replication link is currently down).
#    If the last interaction is too old, the slave will not try to failover
#    at all.
#
# The point "2" can be tuned by user. Specifically a slave will not perform
# the failover if, since the last interaction with the master, the time
# elapsed is greater than:
#
#   (node-timeout * slave-validity-factor) + repl-ping-slave-period
#
# So for example if node-timeout is 30 seconds, and the slave-validity-factor
# is 10, and assuming a default repl-ping-slave-period of 10 seconds, the
# slave will not try to failover if it was not able to talk with the master
# for longer than 310 seconds.
#
# A large slave-validity-factor may allow slaves with too old data to failover
# a master, while a too small value may prevent the cluster from being able to
# elect a slave at all.
#
# For maximum availability, it is possible to set the slave-validity-factor
# to a value of 0, which means, that slaves will always try to failover the
# master regardless of the last time they interacted with the master.
# (However they'll always try to apply a delay proportional to their
# offset rank).
#
# Zero is the only value able to guarantee that when all the partitions heal
# the cluster will always be able to continue.
#
# cluster-slave-validity-factor 10

# Cluster slaves are able to migrate to orphaned masters, that are masters
# that are left without working slaves. This improves the cluster ability
# to resist to failures as otherwise an orphaned master can't be failed over
# in case of failure if it has no working slaves.
#
# Slaves migrate to orphaned masters only if there are still at least a
# given number of other working slaves for their old master. This number
# is the "migration barrier". A migration barrier of 1 means that a slave
# will migrate only if there is at least 1 other working slave for its master
# and so forth. It usually reflects the number of slaves you want for every
# master in your cluster.
#
# Default is 1 (slaves migrate only if their masters remain with at least
# one slave). To disable migration just set it to a very large value.
# A value of 0 can be set but is useful only for debugging and dangerous
# in production.
#
# cluster-migration-barrier 1

# By default Redis Cluster nodes stop accepting queries if they detect there
# is at least an hash slot uncovered (no available node is serving it).
# This way if the cluster is partially down (for example a range of hash slots
# are no longer covered) all the cluster becomes, eventually, unavailable.
# It automatically returns available as soon as all the slots are covered again.
#
# However sometimes you want the subset of the cluster which is working,
# to continue to accept queries for the part of the key space that is still
# covered. In order to do so, just set the cluster-require-full-coverage
# option to no.
#
# cluster-require-full-coverage yes

# In order to setup your cluster make sure to read the documentation
# available at http://redis.io web site.

################################## SLOW LOG ###################################

# The Redis Slow Log is a system to log queries that exceeded a specified
# execution time. The execution time does not include the I/O operations
# like talking with the client, sending the reply and so forth,
# but just the time needed to actually execute the command (this is the only
# stage of command execution where the thread is blocked and can not serve
# other requests in the meantime).
#
# You can configure the slow log with two parameters: one tells Redis
# what is the execution time, in microseconds, to exceed in order for the
# command to get logged, and the other parameter is the length of the
# slow log. When a new command is logged the oldest one is removed from the
# queue of logged commands.

# The following time is expressed in microseconds, so 1000000 is equivalent
# to one second. Note that a negative number disables the slow log, while
# a value of zero forces the logging of every command.
slowlog-log-slower-than 10000

# There is no limit to this length. Just be aware that it will consume memory.
# You can reclaim memory used by the slow log with SLOWLOG RESET.
slowlog-max-len 128

################################ LATENCY MONITOR ##############################

# The Redis latency monitoring subsystem samples different operations
# at runtime in order to collect data related to possible sources of
# latency of a Redis instance.
#
# Via the LATENCY command this information is available to the user that can
# print graphs and obtain reports.
#
# The system only logs operations that were performed in a time equal or
# greater than the amount of milliseconds specified via the
# latency-monitor-threshold configuration directive. When its value is set
# to zero, the latency monitor is turned off.
#
# By default latency monitoring is disabled since it is mostly not needed
# if you don't have latency issues, and collecting data has a performance
# impact, that while very small, can be measured under big load. Latency
# monitoring can easily be enabled at runtime using the command
# "CONFIG SET latency-monitor-threshold <milliseconds>" if needed.
latency-monitor-threshold 0

############################# EVENT NOTIFICATION ##############################

# Redis can notify Pub/Sub clients about events happening in the key space.
# This feature is documented at http://redis.io/topics/notifications
#
# For instance if keyspace events notification is enabled, and a client
# performs a DEL operation on key "foo" stored in the Database 0, two
# messages will be published via Pub/Sub:
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# It is possible to select the events that Redis will notify among a set
# of classes. Every class is identified by a single character:
#
#  K     Keyspace events, published with __keyspace@<db>__ prefix.
#  E     Keyevent events, published with __keyevent@<db>__ prefix.
#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
#  $     String commands
#  l     List commands
#  s     Set commands
#  h     Hash commands
#  z     Sorted set commands
#  x     Expired events (events generated every time a key expires)
#  e     Evicted events (events generated when a key is evicted for maxmemory)
#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.
#
#  The "notify-keyspace-events" takes as argument a string that is composed
#  of zero or multiple characters. The empty string means that notifications
#  are disabled.
#
#  Example: to enable list and generic events, from the point of view of the
#           event name, use:
#
#  notify-keyspace-events Elg
#
#  Example 2: to get the stream of the expired keys subscribing to channel
#             name __keyevent@0__:expired use:
#
#  notify-keyspace-events Ex
#
#  By default all notifications are disabled because most users don't need
#  this feature and the feature has some overhead. Note that if you don't
#  specify at least one of K or E, no events will be delivered.
notify-keyspace-events ""

############################### ADVANCED CONFIG ###############################

# Hashes are encoded using a memory efficient data structure when they have a
# small number of entries, and the biggest entry does not exceed a given
# threshold. These thresholds can be configured using the following directives.
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# Lists are also encoded in a special way to save a lot of space.
# The number of entries allowed per internal list node can be specified
# as a fixed maximum size or a maximum number of elements.
# For a fixed maximum size, use -5 through -1, meaning:
# -5: max size: 64 Kb  <-- not recommended for normal workloads
# -4: max size: 32 Kb  <-- not recommended
# -3: max size: 16 Kb  <-- probably not recommended
# -2: max size: 8 Kb   <-- good
# -1: max size: 4 Kb   <-- good
# Positive numbers mean store up to _exactly_ that number of elements
# per list node.
# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
# but if your use case is unique, adjust the settings as necessary.
list-max-ziplist-size -2

# Lists may also be compressed.
# Compress depth is the number of quicklist ziplist nodes from *each* side of
# the list to *exclude* from compression.  The head and tail of the list
# are always uncompressed for fast push/pop operations.  Settings are:
# 0: disable all list compression
# 1: depth 1 means "don't start compressing until after 1 node into the list,
#    going from either the head or tail"
#    So: [head]->node->node->...->node->[tail]
#    [head], [tail] will always be uncompressed; inner nodes will compress.
# 2: [head]->[next]->node->node->...->node->[prev]->[tail]
#    2 here means: don't compress head or head->next or tail->prev or tail,
#    but compress all nodes between them.
# 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]
# etc.
list-compress-depth 0

# Sets have a special encoding in just one case: when a set is composed
# of just strings that happen to be integers in radix 10 in the range
# of 64 bit signed integers.
# The following configuration setting sets the limit in the size of the
# set in order to use this special memory saving encoding.
set-max-intset-entries 512

# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length and
# elements of a sorted set are below the following limits:
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# HyperLogLog sparse representation bytes limit. The limit includes the
# 16 bytes header. When an HyperLogLog using the sparse representation crosses
# this limit, it is converted into the dense representation.
#
# A value greater than 16000 is totally useless, since at that point the
# dense representation is more memory efficient.
#
# The suggested value is ~ 3000 in order to have the benefits of
# the space efficient encoding without slowing down too much PFADD,
# which is O(N) with the sparse encoding. The value can be raised to
# ~ 10000 when CPU is not a concern, but space is, and the data set is
# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
hll-sparse-max-bytes 3000

# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
# order to help rehashing the main Redis hash table (the one mapping top-level
# keys to values). The hash table implementation Redis uses (see dict.c)
# performs a lazy rehashing: the more operation you run into a hash table
# that is rehashing, the more rehashing "steps" are performed, so if the
# server is idle the rehashing is never complete and some more memory is used
# by the hash table.
#
# The default is to use this millisecond 10 times every second in order to
# actively rehash the main dictionaries, freeing memory when possible.
#
# If unsure:
# use "activerehashing no" if you have hard latency requirements and it is
# not a good thing in your environment that Redis can reply from time to time
# to queries with 2 milliseconds delay.
#
# use "activerehashing yes" if you don't have such hard requirements but
# want to free memory asap when possible.
activerehashing yes

# The client output buffer limits can be used to force disconnection of clients
# that are not reading data from the server fast enough for some reason (a
# common reason is that a Pub/Sub client can't consume messages as fast as the
# publisher can produce them).
#
# The limit can be set differently for the three different classes of clients:
#
# normal -> normal clients including MONITOR clients
# slave  -> slave clients
# pubsub -> clients subscribed to at least one pubsub channel or pattern
#
# The syntax of every client-output-buffer-limit directive is the following:
#
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
#
# A client is immediately disconnected once the hard limit is reached, or if
# the soft limit is reached and remains reached for the specified number of
# seconds (continuously).
# So for instance if the hard limit is 32 megabytes and the soft limit is
# 16 megabytes / 10 seconds, the client will get disconnected immediately
# if the size of the output buffers reach 32 megabytes, but will also get
# disconnected if the client reaches 16 megabytes and continuously overcomes
# the limit for 10 seconds.
#
# By default normal clients are not limited because they don't receive data
# without asking (in a push way), but just after a request, so only
# asynchronous clients may create a scenario where data is requested faster
# than it can read.
#
# Instead there is a default limit for pubsub and slave clients, since
# subscribers and slaves receive data in a push fashion.
#
# Both the hard or the soft limit can be disabled by setting them to zero.
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

# Redis calls an internal function to perform many background tasks, like
# closing connections of clients in timeout, purging expired keys that are
# never requested, and so forth.
#
# Not all tasks are performed with the same frequency, but Redis checks for
# tasks to perform according to the specified "hz" value.
#
# By default "hz" is set to 10. Raising the value will use more CPU when
# Redis is idle, but at the same time will make Redis more responsive when
# there are many keys expiring at the same time, and timeouts may be
# handled with more precision.
#
# The range is between 1 and 500, however a value over 100 is usually not
# a good idea. Most users should use the default of 10 and raise this up to
# 100 only in environments where very low latency is required.
hz 10

# When a child rewrites the AOF file, if the following option is enabled
# the file will be fsync-ed every 32 MB of data generated. This is useful
# in order to commit the file to the disk more incrementally and avoid
# big latency spikes.
aof-rewrite-incremental-fsync yes


```

21832:M 23 Jul 11:40:34.278 # User requested shutdown...
21832:M 23 Jul 11:40:34.278 * Saving the final RDB snapshot before exiting.
21832:M 23 Jul 11:40:34.282 * DB saved on disk
21832:M 23 Jul 11:40:34.282 * Removing the pid file.
21832:M 23 Jul 11:40:34.282 # Redis is now ready to exit, bye bye...
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 3.2.0 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 21907
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

21907:M 23 Jul 11:40:34.289 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
21907:M 23 Jul 11:40:34.289 # Server started, Redis version 3.2.0
21907:M 23 Jul 11:40:34.289 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
21907:M 23 Jul 11:40:34.289 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
21907:M 23 Jul 11:40:34.289 * The server is now ready to accept connections on port 6379



21980:M 23 Jul 11:43:30.178 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
21980:M 23 Jul 11:43:30.178 # Server started, Redis version 3.2.0
21980:M 23 Jul 11:43:30.178 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
21907:M 23 Jul 11:40:34.289 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
21907:M 23 Jul 11:40:34.289 * The server is now ready to accept connections on port 6379
21907:M 23 Jul 11:43:23.321 # User requested shutdown...
21907:M 23 Jul 11:43:23.321 * Saving the final RDB snapshot before exiting.
21907:M 23 Jul 11:43:23.328 * DB saved on disk
21907:M 23 Jul 11:43:23.328 * Removing the pid file.
21907:M 23 Jul 11:43:23.328 # Redis is now ready to exit, bye bye...
21980:M 23 Jul 11:43:30.177 * Increased maximum number of open files to 10032 (it was originally set to 1024).
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 3.2.0 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 21980
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

21980:M 23 Jul 11:43:30.178 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
21980:M 23 Jul 11:43:30.178 # Server started, Redis version 3.2.0
21980:M 23 Jul 11:43:30.178 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
21980:M 23 Jul 11:43:30.178 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
21980:M 23 Jul 11:43:30.178 * DB loaded from disk: 0.000 seconds


22127:M 23 Jul 11:46:02.696 # User requested shutdown...
22127:M 23 Jul 11:46:02.696 * Saving the final RDB snapshot before exiting.
22127:M 23 Jul 11:46:02.701 * DB saved on disk
22127:M 23 Jul 11:46:02.701 * Removing the pid file.
22127:M 23 Jul 11:46:02.701 # Redis is now ready to exit, bye bye...
22196:M 23 Jul 11:46:04.782 * Increased maximum number of open files to 10032 (it was originally set to 1024).
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 3.2.0 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 22196
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

22196:M 23 Jul 11:46:04.783 # Server started, Redis version 3.2.0
22196:M 23 Jul 11:46:04.783 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
22196:M 23 Jul 11:46:04.784 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
22196:M 23 Jul 11:46:04.784 * DB loaded from disk: 0.000 seconds
22196:M 23 Jul 11:46:04.784 * The server is now ready to accept connections on port 6379
~                                                                                             
```


### 总结
1. 主从复制：分为两种方式，rdb方式，无盘方式
2. RDB快照： 根据设置的规则来将DB数据库的数据保存在硬盘上，在redis启动时，将从改文件中恢复数据到redis中
3. AOF

### 参考文献
[Redis内存回收:LRU算法](https://blog.csdn.net/zdy0_2004/article/details/44685615)