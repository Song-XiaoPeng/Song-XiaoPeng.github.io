>Init script setup

设置Init初始化脚本

>You will probably want to create an init script for your new php-fpm. Fortunately, PHP 5.3.3 provides one for you, which you should copy to your init directory and change permissions:

你将很可能的为你的新的php-fpm程序创建一个新的启动脚本。幸运的是，PHP5.3.3 版本为你提供了一个这样的脚本，你应该将它复制到你的初始化目录中，并且修改权限：

```
$ cp <php-5.3.3-source-dir>/sapi/fpm/init.d.php-fpm.in /etc/init.d/php-fpm
$ chmod 755 /etc/init.d/php-fpm
```

>It requires a certain amount of setup. First of all, make sure your php-fpm.conf file is set up to  create a PID file when php-fpm starts. E.g.:

需要一个确切数量（一定的）的配置（设置）。首先，创建一个 PID 文件，确保你的 php-fpm.conf 文件在开启时被设置。（首先，确保你的 php-fpm.conf 文件当php-fpm启动时设置为创建一个PID文件。）例如：

```
pid = /var/run/php-fpm.pid

```

>(also make sure your php-fpm user has permission to create this file).


也要确认你的php-fpm用户有权限去创建这个文件。

>Now open up your new init script (/etc/init.d/php-fpm) and set the variables at the top to their relevant values. E.g.:

现在，打开你的新的init启动脚本 (/etc/init.d/php-fpm) 并且将顶部的变量设置为它们相关的值。例如：

```
prefix=
exec_prefix=
php_fpm_BIN=/sbin/php-fpm
php_fpm_CONF=/etc/php-fpm.conf
php_fpm_PID=/var/run/php-fpm.pid
```

>Your init script is now ready. You should now be able to start, stop and reload php-fpm:

你的初始脚本现在准备好了。你现在应该可以启动，停止和重新加载php-fpm了。

```
$ /etc/init.d/php-fpm start
$ /etc/init.d/php-fpm stop
$ /etc/init.d/php-fpm reload
```

>The one remaining thing you may wish to do is to add your new php-fpm init script to system start-up. E.g. in CentOS:

一个剩下的事情你可能希望去做，将你的新的php-fpm启动脚本添加到系统开机启动中。例如，在CentOS中：

```
$ /sbin/chkconfig php-fpm on
```

>Disclaimer: Although I did just do this on my own server about 20 mins ago, everything I've written here is off the top of my head, so it may not be 100% correct. Also, allow for differences in system setup. Some understanding of what you are doing is assumed.

不承诺： 尽管我在20分钟之前在我的服务器上做了这些工作，我所有写在这里的是（天方夜谭），因此它可能不是100%正确的。同时，允许在系统设置时的差别（此外，考虑到系统设置的差异。）。一些你正在做的理解是假设的。（对你正在做的事情有一些了解是假定的。）

>PHP-FPM is FAST - but be wary of using it while your code base is stored on NFS - under average load your NFS server will feel some serious strain. I have yet to find a work around for this bug: https://bugs.php.net/bug.php?id=52312

>the fpm process supports the USER2 signal, which is used to reload the config file.
```
kill -USR2 [pid]
```
>should do the trick.


>Doesn't work? Enable logging!

>The php-fpm.log file is a great place to fault-find errors and get to the bottom of a problem. But be sure to enable logging for your specific worker pool. Or you won't see anything!

>Example:

>To enable error logging for the default [www] worker pool, add this line in the [www] section of your php-fpm.conf:
```
[www]
catch_workers_output = yes
```

>It is important to note that FPM is not built with the windows binaries.  Many of the guides you may find online rely on php-cgi.exe.  Unfortunately they call it FPM but this is incorrect!

>The executable php-cgi.exe that is bundled with the windows binaries is a FastCGI interface but it is *not* FPM (Fastcgi Process Manager).  php-cgi.exe does not have multi-threading or concurrent request support, nor support for any of the FPM configuration options.

>The only solid information I've gathered into why FPM is not available is a bug report explaining that FPM is built around fork(), which is not natively available on windows (https://bugs.php.net/bug.php?id=62447).

>I'm very unhappy with the way php-fpm handles requests.  
>There isn't even some SCRIPT_FILENAME in the RFC for CGI, an that's the only standard I found to handle the requests.

>Actually what you are doing with PATH_TRANSLATED is supposed to translate to the path, which is broken by media wikis, as they use the PATH_INFO to find the ressource, not some script.

>In the original CGI context, the PATH_INFO is passed to the CGI binary to specify some ressource argument. So actually
```
    SCRIPT_NAME  ~ argv0
    PATH_INFO      ~ argv1
```
>in command context.

>Conclusion: We should rewrite php-fpm to obey the rfc3875 CGI standard.  
>Having SCRIPT_NAME pointing to /something.php, must translate to 

```
    CWD/something.php
```

>CWD is the working directory where php-fpm is started (or configured to change to).

>In case of chroot CWD = "".

>In any case the SCRIPT_NAME php script can be found with ./SCRIPT_NAME, from the CWD. So the undocumented not standardized SCRIPT_FILENAME should vanish! It breaks the CGI standard.

>php-fpm is not avaliable on Windows, but you can use IIS or Apache as the "fastcgi process manager".

>If you have to use Nginx, here is a solution. Nginx provides a load balancing module. We can distribute the request to different php-cgi.exe process.

```
<http://nginx.org/en/docs/http/load_balancing.html>
<http://nginx.org/en/docs/http/ngx_http_upstream_module.html>
```

>This is the origin nginx conf.
```
location ~ \.php$ {
    try_files  $uri = 404;
    fastcgi_pass  127.0.0.1:9000;
    fastcgi_index  index.php;
    include  fastcgi.conf;
}
```

>You can replace it by
```
upstream php {
    server  127.0.0.1:9000;
    server  127.0.0.1:9001;
    server  127.0.0.1:9002;
    server  127.0.0.1:9003;
}

location ~ \.php$ {
    try_files  $uri = 404;
    fastcgi_pass  php;
    fastcgi_index  index.php;
    include  fastcgi.conf;
}
```

>CAUTION!!

>php-cgi.exe process will die after several requests, so you have to restart the php-cgi.exe manually to keep a process listening the port.

>DON'T USE THIS SOLUTION IN PRODUCTION!!

### 参考资料
[php 官方手册](http://www.php.net/manual/zh/install.fpm.php)